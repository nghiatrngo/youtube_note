<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Note Clipper - Cloud Version</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .sidebar { transition: all 0.3s ease; }
        .sidebar-collapsed { width: 0; overflow: hidden; }
        .h-full { height: calc(100vh - 4rem); }
        
        /* Video player styling */
        #player-container {
            position: relative;
            width: 100%;
        }
        
        #player {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #player-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Ensure YouTube iframe fills container */
        #player iframe {
            width: 100% !important;
            height: 100% !important;
        }
        
        /* Sidebar collapsible styling */
        .sidebar {
            transition: all 0.3s ease;
            width: 20rem; /* 320px */
        }
        
        .sidebar.collapsed {
            width: 0;
            overflow: hidden;
            padding: 0;
            margin: 0;
        }
        
        .sidebar.collapsed * {
            display: none;
        }
        
        /* Main content expands when sidebar is collapsed */
        .main-content {
            transition: all 0.3s ease;
        }
        
        /* Theme CSS Variables */
        :root {
            --bg-primary: #f3f4f6;
            --bg-secondary: #ffffff;
            --bg-sidebar: #ffffff;
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --border-color: #e5e7eb;
            --accent-color: #3b82f6;
            --accent-hover: #2563eb;
        }
        
        /* Light Theme (Default) */
        [data-theme="light"] {
            --bg-primary: #f3f4f6;
            --bg-secondary: #ffffff;
            --bg-sidebar: #ffffff;
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --border-color: #e5e7eb;
            --accent-color: #3b82f6;
            --accent-hover: #2563eb;
        }
        
        /* Dark Theme */
        [data-theme="dark"] {
            --bg-primary: #111827;
            --bg-secondary: #1f2937;
            --bg-sidebar: #374151;
            --text-primary: #f9fafb;
            --text-secondary: #d1d5db;
            --border-color: #4b5563;
            --accent-color: #60a5fa;
            --accent-hover: #3b82f6;
        }
        
        /* Blue Theme */
        [data-theme="blue"] {
            --bg-primary: #eff6ff;
            --bg-secondary: #ffffff;
            --bg-sidebar: #dbeafe;
            --text-primary: #1e40af;
            --text-secondary: #3b82f6;
            --border-color: #93c5fd;
            --accent-color: #2563eb;
            --accent-hover: #1d4ed8;
        }
        
        /* Green Theme */
        [data-theme="green"] {
            --bg-primary: #f0fdf4;
            --bg-secondary: #ffffff;
            --bg-sidebar: #dcfce7;
            --text-primary: #166534;
            --text-secondary: #16a34a;
            --border-color: #86efac;
            --accent-color: #16a34a;
            --accent-hover: #15803d;
        }
        
        /* Purple Theme */
        [data-theme="purple"] {
            --bg-primary: #faf5ff;
            --bg-secondary: #ffffff;
            --bg-sidebar: #f3e8ff;
            --text-primary: #7c3aed;
            --text-secondary: #a855f7;
            --border-color: #c4b5fd;
            --accent-color: #9333ea;
            --accent-hover: #7c3aed;
        }
        
        /* Apply theme variables to entire page */
        body {
            background-color: var(--bg-primary) !important;
            color: var(--text-primary) !important;
        }
        
        header {
            background-color: var(--bg-secondary) !important;
            border-color: var(--border-color) !important;
        }
        
        #sidebar {
            background-color: var(--bg-sidebar) !important;
            border-color: var(--border-color) !important;
        }
        
        /* Override Tailwind classes with theme variables */
        .bg-white, .bg-gray-100 {
            background-color: var(--bg-secondary) !important;
        }
        
        .bg-gray-50 {
            background-color: var(--bg-primary) !important;
        }
        
        .text-gray-800, .text-gray-900 {
            color: var(--text-primary) !important;
        }
        
        .text-gray-600, .text-gray-700 {
            color: var(--text-secondary) !important;
        }
        
        .text-gray-500 {
            color: var(--text-secondary) !important;
        }
        
        .border-gray-200, .border-gray-300 {
            border-color: var(--border-color) !important;
        }
        
        /* Theme-specific button colors */
        .bg-blue-600 {
            background-color: var(--accent-color) !important;
        }
        
        .hover\:bg-blue-700:hover {
            background-color: var(--accent-hover) !important;
        }
        
        /* Modal and form styling */
        #auth-modal .bg-white {
            background-color: var(--bg-secondary) !important;
        }
        
        #auth-modal .text-gray-700 {
            color: var(--text-primary) !important;
        }
        
        #auth-modal .border-gray-300 {
            border-color: var(--border-color) !important;
        }
        
        /* Input fields */
        input, textarea {
            background-color: var(--bg-secondary) !important;
            color: var(--text-primary) !important;
            border-color: var(--border-color) !important;
        }
        
        /* Focus states */
        input:focus, textarea:focus {
            border-color: var(--accent-color) !important;
            ring-color: var(--accent-color) !important;
        }
        
        /* Toast notifications */
        #toast {
            background-color: var(--accent-color) !important;
        }
        
        /* Video controls toolbar */
        #video-controls-toolbar {
            background-color: var(--bg-secondary) !important;
        }
        
        /* Main content area */
        main {
            background-color: var(--bg-secondary) !important;
        }
        
        /* Note cards and containers */
        .bg-white.border {
            background-color: var(--bg-secondary) !important;
            border-color: var(--border-color) !important;
        }
        
        /* User profile section */
        .bg-gradient-to-r {
            background: linear-gradient(to right, var(--accent-color), var(--accent-hover)) !important;
        }
        
        /* Additional theme overrides for complete coverage */
        .bg-gray-100 {
            background-color: var(--bg-primary) !important;
        }
        
        .bg-gray-200 {
            background-color: var(--bg-secondary) !important;
        }
        
        .text-gray-400 {
            color: var(--text-secondary) !important;
        }
        
        .text-gray-300 {
            color: var(--text-secondary) !important;
        }
        
        /* Button hover states */
        .hover\:bg-gray-100:hover {
            background-color: var(--bg-primary) !important;
        }
        
        .hover\:bg-gray-200:hover {
            background-color: var(--bg-secondary) !important;
        }
        
        /* Shadow and border utilities */
        .shadow-sm, .shadow-lg {
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05), 0 10px 15px -3px rgba(0, 0, 0, 0.1) !important;
        }
        
        /* Ensure video player container maintains black background */
        #player-container {
            background-color: #000000 !important;
        }
        
        /* Theme dropdown styling */
        #theme-dropdown {
            background-color: var(--bg-secondary) !important;
            border-color: var(--border-color) !important;
        }
        
        #theme-dropdown .theme-option:hover {
            background-color: var(--bg-primary) !important;
        }
        
        /* View toggle button styling */
        .active-view {
            background-color: #2563eb !important;
            color: white !important;
        }
        
        #video-note-view-btn, #note-preview-view-btn {
            transition: all 0.2s ease;
        }
    </style>
</head>
<body class="bg-gray-100 h-screen">
    <!-- Header -->
    <header class="bg-white shadow-sm border-b px-4 py-3">
        <div class="flex justify-between items-center">
            <div class="flex items-center space-x-3">
                <!-- Sidebar Toggle Button -->
                <button id="sidebar-toggle" class="text-gray-600 hover:text-gray-800 p-2 rounded-lg hover:bg-gray-100 transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                    </svg>
                </button>
                <h1 class="text-lg font-bold text-gray-800">YouTube Note Clipper</h1>
                
                <!-- Load Video Section -->
                <div class="flex items-center space-x-2">
                    <input type="text" id="url-input" placeholder="Paste YouTube URL here..." class="px-3 py-1.5 border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" style="min-width: 300px;">
                    <button id="toolbar-load-video" class="bg-blue-600 text-white px-3 py-1.5 rounded text-sm hover:bg-blue-700 transition">
                        Load Video
                    </button>
                </div>
            </div>

            <!-- Video Controls Toolbar -->
            <div id="video-controls-toolbar" class="flex items-center space-x-2 hidden">
                <button id="toolbar-play-pause" class="bg-green-500 hover:bg-green-600 text-white px-2 py-1 rounded text-xs transition">
                    ▶ Play
                </button>
                <button id="toolbar-frame-back" class="bg-gray-500 hover:bg-gray-600 text-white px-2 py-1 rounded text-xs transition">
                    -1 Frame
                </button>
                <button id="toolbar-frame-forward" class="bg-gray-500 hover:bg-gray-600 text-white px-2 py-1 rounded text-xs transition">
                    +1 Frame
                </button>
                <div class="w-px h-6 bg-gray-300 mx-1"></div>
                <button id="toolbar-set-start" class="bg-blue-500 hover:bg-blue-600 text-white px-2 py-1 rounded text-xs transition">
                    Set Start
                </button>
                <button id="toolbar-set-end" class="bg-blue-500 hover:bg-blue-600 text-white px-2 py-1 rounded text-xs transition">
                    Set End
                </button>
                <div class="w-px h-6 bg-gray-300 mx-1"></div>
                <button id="toolbar-stop-looping" class="hidden bg-red-500 hover:bg-red-600 text-white px-2 py-1 rounded text-xs transition">
                    Stop Loop
                </button>
                <button id="toolbar-speed-50" class="bg-purple-500 hover:bg-purple-600 text-white px-2 py-1 rounded text-xs transition">
                    50%
                </button>
                <button id="toolbar-speed-150" class="bg-purple-500 hover:bg-purple-600 text-white px-2 py-1 rounded text-xs transition">
                    150%
                </button>
            </div>

            <div class="flex items-center space-x-3">
                <!-- Theme Selector -->
                <div class="relative">
                    <button id="theme-selector" class="bg-gray-600 text-white px-3 py-1.5 rounded text-sm hover:bg-gray-700 transition flex items-center space-x-2">
                        <span>🎨</span>
                        <span>Theme</span>
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </button>
                    <div id="theme-dropdown" class="absolute right-0 mt-2 w-48 bg-white border border-gray-200 rounded-lg shadow-lg z-50 hidden">
                        <div class="py-2">
                            <button class="theme-option w-full text-left px-4 py-2 text-sm hover:bg-gray-100 transition" data-theme="light">
                                ☀️ Light
                            </button>
                            <button class="theme-option w-full text-left px-4 py-2 text-sm hover:bg-gray-100 transition" data-theme="dark">
                                🌙 Dark
                            </button>
                            <button class="theme-option w-full text-left px-4 py-2 text-sm hover:bg-gray-100 transition" data-theme="blue">
                                🔵 Blue
                            </button>
                            <button class="theme-option w-full text-left px-4 py-2 text-sm hover:bg-gray-100 transition" data-theme="green">
                                🟢 Green
                            </button>
                            <button class="theme-option w-full text-left px-4 py-2 text-sm hover:bg-gray-100 transition" data-theme="purple">
                                🟣 Purple
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- User Info (hidden by default) -->
                <div id="user-info" class="hidden flex items-center space-x-3">
                    <span class="text-gray-600 text-sm">Welcome, <span id="username-display">Username</span></span>
                    <button id="logout-btn" class="bg-red-500 text-white px-3 py-1 rounded text-sm hover:bg-red-600 transition">Logout</button>
                </div>
                
                <!-- Login Button (shown by default) -->
                <button id="login-btn" class="bg-blue-600 text-white px-3 py-1.5 rounded text-sm hover:bg-blue-700 transition">Login</button>
            </div>
        </div>
    </header>

    <!-- Authentication Modal -->
    <div id="auth-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-lg p-6 w-full max-w-md mx-4">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold">Login / Register</h2>
                <button id="close-auth" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
                </div>
            
            <!-- Login Form -->
            <form id="login-form" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Email</label>
                    <input type="email" id="login-email" required class="mt-1 w-full p-2 border border-gray-300 rounded-md">
            </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">Password</label>
                    <input type="password" id="login-password" required class="mt-1 w-full p-2 border border-gray-300 rounded-md">
                </div>
                <button type="submit" class="w-full bg-blue-600 text-white py-2 rounded-md hover:bg-blue-700">Login</button>
                <button type="button" id="show-register" class="w-full text-blue-600 hover:underline">Create Account</button>
            </form>
            
            <!-- Register Form -->
            <form id="register-form" class="space-y-4 hidden">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Username</label>
                    <input type="text" id="register-username" required class="mt-1 w-full p-2 border border-gray-300 rounded-md">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">Email</label>
                    <input type="email" id="register-email" required class="mt-1 w-full p-2 border border-gray-300 rounded-md">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">Password</label>
                    <input type="password" id="register-password" required minlength="6" class="mt-1 w-full p-2 border border-gray-300 rounded-md">
                </div>
                <button type="submit" class="w-full bg-green-600 text-white py-2 rounded-md hover:bg-green-700">Create Account</button>
                <button type="button" id="show-login" class="w-full text-blue-600 hover:underline">Already have account?</button>
            </form>
                    </div>
                </div>

    <!-- Main Container -->
    <div class="flex h-full">
        <!-- Sidebar -->
        <div id="sidebar" class="sidebar w-80 bg-white border-r border-gray-200 flex-shrink-0">
                <!-- User Profile Section -->
                <div class="p-4">
                    <div class="bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-lg p-4 mb-4">
                        <div class="flex items-center space-x-3">
                            <div class="w-12 h-12 bg-white bg-opacity-20 rounded-full flex items-center justify-center text-xl font-bold">
                                <span id="user-avatar">U</span>
                            </div>
                            <div>
                                <h2 class="text-lg font-bold" id="profile-username">Username</h2>
                                <p class="text-blue-100 text-sm" id="profile-email">email@example.com</p>
                            </div>
                        </div>
                        <div class="flex space-x-4 mt-3 text-sm">
                            <div>
                                <span class="font-bold" id="total-notes">0</span>
                                <span class="text-blue-100"> notes</span>
                            </div>
                            <div>
                                <span class="font-bold" id="total-videos">0</span>
                                <span class="text-blue-100"> videos</span>
                            </div>
                        </div>
                    </div>

                    <!-- All Notes Sidebar -->
                    <div class="bg-white border border-gray-200 rounded-lg p-3">
                        <div class="flex justify-between items-center mb-3">
                            <h3 class="text-sm font-semibold text-gray-800">All My Notes</h3>
                            <button id="refresh-all-notes" class="text-blue-600 hover:text-blue-800 text-xs">Refresh</button>
                        </div>
                        <div id="all-notes-sidebar" class="space-y-3 max-h-[600px] overflow-y-auto">
                            <p class="text-gray-500 text-center py-6 text-sm">Loading notes...</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Main Content Area -->
            <div class="flex-1 flex flex-col min-w-0">
                <!-- View Toggle Buttons -->
                <div class="bg-gray-800 p-2 flex justify-center space-x-4">
                    <button id="video-note-view-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition active-view">
                        📺 Video Notes
                    </button>
                    <button id="note-preview-view-btn" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition">
                        📝 Note Preview
                    </button>
                </div>
                
                <!-- Main Content -->
                <main class="flex-1 bg-white p-4 lg:p-6 w-full">


                


                    <!-- Video-Note View -->
                    <div id="video-note-view" class="grid grid-cols-1 xl:grid-cols-4 gap-4 lg:gap-6">
                    <!-- Video Player -->
                        <div class="xl:col-span-3">
                            <!-- YouTube Player -->
                        <div id="player-container" class="bg-black rounded-lg overflow-hidden shadow-inner" style="aspect-ratio: 16/9;">
                                 <div id="player-placeholder" class="w-full h-full flex items-center justify-center text-gray-400">
                                    <svg class="w-16 h-16" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                                    <span class="ml-4">Video will appear here</span>
                                </div>
                            <div id="player" class="w-full h-full"></div>
                            </div>
                            </div>

                    <!-- Right Sidebar with Note Input and Current Notes -->
                    <div class="xl:col-span-1 space-y-4">
                        <!-- Note Input Area -->
                        <div class="bg-white border border-gray-200 rounded-lg p-4">
                            <div class="flex items-center justify-between mb-3">
                                <h3 class="text-lg font-semibold text-gray-800">Create a Clip</h3>
                                <div class="flex items-center space-x-3 text-sm text-gray-600">
                                    <span>Start: <span id="toolbar-start-time" class="font-mono">00:00</span></span>
                                    <span>End: <span id="toolbar-end-time" class="font-mono">00:00</span></span>
                                    </div>
                                </div>
                                <textarea id="note-text" class="w-full p-3 border border-gray-300 rounded-lg h-24 focus:ring-2 focus:ring-blue-500" placeholder="Write your note for this clip..."></textarea>
                                <button id="add-note" class="mt-3 w-full bg-green-500 text-white font-semibold px-6 py-3 rounded-lg hover:bg-green-600 transition shadow-md">
                                    Add Note & Clip
                                </button>
                        </div>

                        <!-- Current Video Notes -->
                            <div class="bg-white border border-gray-200 rounded-lg p-4 h-fit">
                                <h3 class="text-lg font-semibold mb-3 text-gray-800">
                    Current Video Notes
                    <button onclick="checkDatabaseHealth()" class="ml-2 text-xs bg-blue-100 text-blue-700 py-1 px-2 rounded hover:bg-blue-200 transition">
                        🏥 Health Check
                    </button>
                </h3>
                                <div id="current-video-notes" class="space-y-3 max-h-[600px] overflow-y-auto">
                                    <p class="text-gray-500 text-center py-8">No video loaded</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Note-Preview View -->
                    <div id="note-preview-view" class="hidden">
                        <div class="bg-white border border-gray-200 rounded-lg p-6">
                            <div class="flex items-center justify-between mb-6">
                                <h3 class="text-2xl font-bold text-gray-800">All Notes Preview</h3>
                                <div class="flex items-center space-x-3">
                                    <button id="expand-all-notes" class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition">
                                        📖 Expand All
                                    </button>
                                    <button id="collapse-all-notes" class="px-4 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 transition">
                                        📕 Collapse All
                                    </button>
                                    <select id="sort-notes" class="px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                                        <option value="newest">Newest First</option>
                                        <option value="oldest">Oldest First</option>
                                        <option value="alphabetical">Alphabetical</option>
                                        <option value="video">By Video</option>
                                    </select>
                                </div>
                            </div>
                            <div id="all-notes-preview" class="space-y-4">
                                <!-- Notes will be populated here -->
                            </div>
                        </div>
                    </div>
                </main>
        </div>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="fixed bottom-5 right-5 text-white py-2 px-4 rounded-lg shadow-lg transform transition-all duration-300 opacity-0 translate-y-2"></div>

    <script>
        // Cloud-enabled version - can use either localStorage or cloud API
        console.log('🚀 YouTube Note Clipper - Cloud Version Loaded');
        
        // Configuration - Supabase-enabled API
        const API_BASE = 'https://youtube-note-clipper-api.onrender.com/api';
        const USE_CLOUD = true; // Set to false to use localStorage only

        // Global variables
        let player;
        let currentVideoId = '';
        let currentVideoTitle = '';
        let notes = [];
        let allNotes = [];
        let tempStartTime = 0;
        let tempEndTime = 0;
        let currentUser = null;
        let loopingNoteIndex = -1;
        let loopInterval;

        // DOM Elements - will be initialized after DOM loads
        let authModal, loginForm, registerForm, showRegisterBtn, showLoginBtn, logoutBtn;
        let userInfo, usernameDisplay, noteTaker;
        let addNoteBtn, noteText, stopLoopingBtn, loopingStatus, playerPlaceholder, toast;
        let sidebarToggle, sidebar, mainContent;
        let videoToolbar, videoControlsToolbar, toolbarLoadVideo, urlInput, toolbarSetStart, toolbarSetEnd;
        let toolbarStartTime, toolbarEndTime, toolbarStopLooping, toolbarLoopingStatus;
        let toolbarPlayPause, toolbarFrameBack, toolbarFrameForward, toolbarSpeed50, toolbarSpeed150;
        let themeSelector, themeDropdown;

        // Check authentication on load
        document.addEventListener('DOMContentLoaded', () => {
            try {
                console.log('📱 DOM loaded, initializing application...');
                
                // Initialize DOM elements
                authModal = document.getElementById('auth-modal');
                loginForm = document.getElementById('login-form');
                registerForm = document.getElementById('register-form');
                showRegisterBtn = document.getElementById('show-register');
                showLoginBtn = document.getElementById('show-login');
                logoutBtn = document.getElementById('logout-btn');
                userInfo = document.getElementById('user-info');
                usernameDisplay = document.getElementById('username-display');


                noteTaker = document.getElementById('note-taker');
                addNoteBtn = document.getElementById('add-note');
                noteText = document.getElementById('note-text');
                stopLoopingBtn = document.getElementById('stop-looping');
                loopingStatus = document.getElementById('looping-status');
                playerPlaceholder = document.getElementById('player-placeholder');
                toast = document.getElementById('toast');
                sidebarToggle = document.getElementById('sidebar-toggle');
                sidebar = document.getElementById('sidebar');
                mainContent = document.querySelector('.flex-1');
                
                // Theme selector elements
                themeSelector = document.getElementById('theme-selector');
                themeDropdown = document.getElementById('theme-dropdown');
            
                // Toolbar elements
                videoControlsToolbar = document.getElementById('video-controls-toolbar');
                toolbarLoadVideo = document.getElementById('toolbar-load-video');
                urlInput = document.getElementById('url-input');
                toolbarSetStart = document.getElementById('toolbar-set-start');
                toolbarSetEnd = document.getElementById('toolbar-set-end');
                toolbarStartTime = document.getElementById('toolbar-start-time');
                toolbarEndTime = document.getElementById('toolbar-end-time');
                toolbarStopLooping = document.getElementById('toolbar-stop-looping');
                toolbarLoopingStatus = document.getElementById('toolbar-looping-status');
                toolbarPlayPause = document.getElementById('toolbar-play-pause');
                toolbarFrameBack = document.getElementById('toolbar-frame-back');
                toolbarFrameForward = document.getElementById('toolbar-frame-forward');
                toolbarSpeed50 = document.getElementById('toolbar-speed-50');
                toolbarSpeed150 = document.getElementById('toolbar-speed-150');
            
                // Add event listeners
                if (stopLoopingBtn) stopLoopingBtn.addEventListener('click', stopLoop);

                // Authentication event listeners
                if (showRegisterBtn) showRegisterBtn.addEventListener('click', () => {
                    loginForm.classList.add('hidden');
                    registerForm.classList.remove('hidden');
                });

                if (showLoginBtn) showLoginBtn.addEventListener('click', () => {
                    registerForm.classList.add('hidden');
                    loginForm.classList.remove('hidden');
                });

                if (logoutBtn) logoutBtn.addEventListener('click', handleLogout);

                // Form submissions
                if (loginForm) loginForm.addEventListener('submit', handleLogin);
                if (registerForm) registerForm.addEventListener('submit', handleRegister);
                
                // Sidebar toggle
                if (sidebarToggle) sidebarToggle.addEventListener('click', toggleSidebar);
                
                // Initialize sidebar to collapsed state by default
                if (sidebar && mainContent) {
                    sidebar.classList.add('collapsed');
                    mainContent.classList.add('sidebar-collapsed');
                    console.log('✅ Sidebar initialized to collapsed state');
                }
                
                // View toggle buttons
                const videoNoteViewBtn = document.getElementById('video-note-view-btn');
                const notePreviewViewBtn = document.getElementById('note-preview-view-btn');
                
                if (videoNoteViewBtn) {
                    videoNoteViewBtn.addEventListener('click', switchToVideoNoteView);
                }
                if (notePreviewViewBtn) {
                    notePreviewViewBtn.addEventListener('click', switchToNotePreviewView);
                }
                
                // Note preview controls
                const expandAllNotesBtn = document.getElementById('expand-all-notes');
                const collapseAllNotesBtn = document.getElementById('collapse-all-notes');
                const sortNotesSelect = document.getElementById('sort-notes');
                
                if (expandAllNotesBtn) {
                    expandAllNotesBtn.addEventListener('click', expandAllNotes);
                }
                if (collapseAllNotesBtn) {
                    collapseAllNotesBtn.addEventListener('click', collapseAllNotes);
                }
                if (sortNotesSelect) {
                    sortNotesSelect.addEventListener('change', renderNotePreview);
                }
                
                // Toolbar event listeners
                if (toolbarLoadVideo) toolbarLoadVideo.addEventListener('click', handleLoadVideo);
                
                // URL input event listeners
                if (urlInput) {
                    urlInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            handleLoadVideo();
                        }
                    });
                }
                if (toolbarSetStart) toolbarSetStart.addEventListener('click', () => setTime('start'));
                if (toolbarSetEnd) toolbarSetEnd.addEventListener('click', () => setTime('end'));
                if (toolbarStopLooping) toolbarStopLooping.addEventListener('click', stopLoop);
                if (toolbarPlayPause) toolbarPlayPause.addEventListener('click', togglePlayPause);
                if (toolbarFrameBack) {
                    let frameBackInterval;
                    
                    // Mouse events for desktop
                    toolbarFrameBack.addEventListener('mousedown', () => {
                        // Start frame seeking every 0.5 seconds
                        frameBackInterval = setInterval(() => seekFrame(-1), 500);
                    });
                    toolbarFrameBack.addEventListener('mouseup', () => {
                        // Stop frame seeking when mouse is released
                        if (frameBackInterval) {
                            clearInterval(frameBackInterval);
                            frameBackInterval = null;
                        }
                    });
                    toolbarFrameBack.addEventListener('mouseleave', () => {
                        // Stop frame seeking when mouse leaves button
                        if (frameBackInterval) {
                            clearInterval(frameBackInterval);
                            frameBackInterval = null;
                        }
                    });
                    
                    // Touch events for mobile
                    toolbarFrameBack.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        frameBackInterval = setInterval(() => seekFrame(-1), 500);
                    });
                    toolbarFrameBack.addEventListener('touchend', () => {
                        if (frameBackInterval) {
                            clearInterval(frameBackInterval);
                            frameBackInterval = null;
                        }
                    });
                    
                    // Single click/tap for immediate frame movement
                    toolbarFrameBack.addEventListener('click', () => seekFrame(-1));
                }
                
                if (toolbarFrameForward) {
                    let frameForwardInterval;
                    
                    // Mouse events for desktop
                    toolbarFrameForward.addEventListener('mousedown', () => {
                        // Start frame seeking every 0.5 seconds
                        frameForwardInterval = setInterval(() => seekFrame(1), 500);
                    });
                    toolbarFrameForward.addEventListener('mouseup', () => {
                        // Stop frame seeking when mouse is released
                        if (frameForwardInterval) {
                            clearInterval(frameForwardInterval);
                            frameForwardInterval = null;
                        }
                    });
                    toolbarFrameForward.addEventListener('mouseleave', () => {
                        // Stop frame seeking when mouse leaves button
                        if (frameForwardInterval) {
                            clearInterval(frameForwardInterval);
                            frameForwardInterval = null;
                        }
                    });
                    
                    // Touch events for mobile
                    toolbarFrameForward.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        frameForwardInterval = setInterval(() => seekFrame(1), 500);
                    });
                    toolbarFrameForward.addEventListener('touchend', () => {
                        if (frameForwardInterval) {
                            clearInterval(frameForwardInterval);
                            frameForwardInterval = null;
                        }
                    });
                    
                    // Single click/tap for immediate frame movement
                    toolbarFrameForward.addEventListener('click', () => seekFrame(1));
                }
                if (toolbarSpeed50) {
                    let isActive = false;
                    toolbarSpeed50.addEventListener('click', () => {
                        if (!isActive) {
                            setPlaybackSpeed(0.5);
                            isActive = true;
                        } else {
                            setPlaybackSpeed(1.0);
                            isActive = false;
                        }
                    });
                }
                
                if (toolbarSpeed150) {
                    let isActive = false;
                    toolbarSpeed150.addEventListener('click', () => {
                        if (!isActive) {
                            setPlaybackSpeed(1.5);
                            isActive = true;
                        } else {
                            setPlaybackSpeed(1.0);
                            isActive = false;
                        }
                    });
                }
                
                // Note taking event listeners
                if (addNoteBtn) {
                    console.log('✅ Add note button found, adding event listener');
                    addNoteBtn.addEventListener('click', handleAddNote);
                } else {
                    console.log('❌ Add note button not found');
                }
                
                // Theme selector event listeners
                if (themeSelector) {
                    themeSelector.addEventListener('click', toggleThemeDropdown);
                }
                
                // Theme option event listeners
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('theme-option')) {
                        const theme = e.target.getAttribute('data-theme');
                        setTheme(theme);
                        hideThemeDropdown();
                    }
                });
                
                // Close theme dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!themeSelector?.contains(e.target) && !themeDropdown?.contains(e.target)) {
                        hideThemeDropdown();
                    }
                });
                

                

            
            // Login button event listener
            const loginBtn = document.getElementById('login-btn');
            if (loginBtn) loginBtn.addEventListener('click', showAuthModal);
            
            // Close auth modal button
            const closeAuthBtn = document.getElementById('close-auth');
            if (closeAuthBtn) closeAuthBtn.addEventListener('click', hideAuthModal);
            
            // Initialize UI elements
            if (stopLoopingBtn) {
                stopLoopingBtn.classList.add('hidden');
            }
            if (loopingStatus) {
                loopingStatus.textContent = '';
            }
            
            console.log('✅ DOM elements initialized, checking authentication...');
            
            // Load saved theme
            loadSavedTheme();
            
            checkAuth();
            
            // Restore previous page state after authentication
            setTimeout(() => {
                restorePageState();
            }, 1000);
            } catch (error) {
                console.error('❌ Error during initialization:', error);
                // Show error message to user
                if (toast) {
                    showToast('Error initializing application. Please refresh the page.', 'error');
                }
            }
        });

        // Authentication functions
        function checkAuth() {
            try {
                if (USE_CLOUD) {
                    // Check cloud token
                    const token = localStorage.getItem('cloudToken');
                    if (token) {
                        const cloudUser = localStorage.getItem('cloudUser');
                        if (cloudUser) {
                            currentUser = JSON.parse(cloudUser);
                            hideAuthModal();
                            loadUserNotes();
                        } else {
                            // SECURITY: Clear invalid token
                            localStorage.removeItem('cloudToken');
                            currentUser = null;
                            resetPageToInitialState();
                            showAuthModal();
                        }
                    } else {
                        currentUser = null;
                        resetPageToInitialState();
                        showAuthModal();
                    }
                } else {
                    // Check localStorage
                    const user = localStorage.getItem('currentUser');
                    if (user) {
                        currentUser = JSON.parse(user);
                        hideAuthModal();
                        loadUserNotes();
                    } else {
                        currentUser = null;
                        resetPageToInitialState();
                        showAuthModal();
                    }
                }
            } catch (error) {
                console.error('❌ Error during authentication check:', error);
                // SECURITY: Clear potentially corrupted data
                if (USE_CLOUD) {
                    localStorage.removeItem('cloudToken');
                    localStorage.removeItem('cloudUser');
                } else {
                    localStorage.removeItem('currentUser');
                }
                currentUser = null;
                resetPageToInitialState();
                // Fallback to showing auth modal
                showAuthModal();
            }
        }

        function showAuthModal() {
            try {
                if (authModal) authModal.classList.remove('hidden');
                if (userInfo) userInfo.classList.add('hidden');
                // Show login button when showing auth modal
                if (document.getElementById('login-btn')) {
                    document.getElementById('login-btn').classList.remove('hidden');
                }
            } catch (error) {
                console.error('❌ Error showing auth modal:', error);
            }
        }

        function hideAuthModal() {
            try {
                if (authModal) authModal.classList.add('hidden');
                
                // Check if user is authenticated to determine what to show
                if (currentUser) {
                    // User is logged in - show user info and hide login button
                    if (userInfo) userInfo.classList.remove('hidden');
                    if (document.getElementById('login-btn')) {
                        document.getElementById('login-btn').classList.add('hidden');
                    }
                    if (usernameDisplay) {
                        usernameDisplay.textContent = currentUser.username;
                    }
                    updateUserProfile();
                } else {
                    // User is not authenticated - hide user info and show login button
                    if (userInfo) userInfo.classList.add('hidden');
                    if (document.getElementById('login-btn')) {
                        document.getElementById('login-btn').classList.remove('hidden');
                    }
                    if (usernameDisplay) {
                        usernameDisplay.textContent = '';
                    }
                }
            } catch (error) {
                console.error('❌ Error hiding auth modal:', error);
            }
        }
        
        // Sidebar toggle function
        function toggleSidebar() {
            if (sidebar && mainContent) {
                sidebar.classList.toggle('collapsed');
                
                // Update toggle button icon
                if (sidebarToggle) {
                    const icon = sidebarToggle.querySelector('svg');
                    if (icon) {
                        if (sidebar.classList.contains('collapsed')) {
                            // Show expand icon
                            icon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5l7 7-7 7M5 5l7 7-7 7"></path>';
                        } else {
                            // Show collapse icon
                            icon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>';
                        }
                    }
                }
            }
        }
        

        

        
        // Theme functions
        function toggleThemeDropdown() {
            if (themeDropdown) {
                themeDropdown.classList.toggle('hidden');
            }
        }
        
        function hideThemeDropdown() {
            if (themeDropdown) {
                themeDropdown.classList.add('hidden');
            }
        }
        
        function setTheme(theme) {
            // Remove all theme classes
            document.documentElement.removeAttribute('data-theme');
            document.body.removeAttribute('data-theme');
            
            // Set new theme
            document.documentElement.setAttribute('data-theme', theme);
            document.body.setAttribute('data-theme', theme);
            
            // Save theme preference
            localStorage.setItem('selectedTheme', theme);
            
            // Show feedback
            const themeNames = {
                'light': 'Light',
                'dark': 'Dark',
                'blue': 'Blue',
                'green': 'Green',
                'purple': 'Purple'
            };
            showToast(`Theme changed to ${themeNames[theme]}`, 'success');
        }
        
        function loadSavedTheme() {
            const savedTheme = localStorage.getItem('selectedTheme');
            if (savedTheme) {
                setTheme(savedTheme);
            }
        }
        


        // Cloud API functions
        async function cloudLogin(email, password) {
            try {
                const response = await fetch(`${API_BASE}/auth/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email, password })
                });

                const data = await response.json();
                
                if (response.ok) {
                    localStorage.setItem('cloudToken', data.token);
                    localStorage.setItem('cloudUser', JSON.stringify(data.user));
                    currentUser = data.user;
                    return { success: true };
                } else {
                    return { success: false, message: data.message };
                }
            } catch (error) {
                console.error('Cloud login error:', error);
                return { success: false, message: 'Network error' };
            }
        }

        async function cloudRegister(username, email, password) {
            try {
                const response = await fetch(`${API_BASE}/auth/register`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, email, password })
                });

                const data = await response.json();
                
                if (response.ok) {
                    localStorage.setItem('cloudToken', data.token);
                    localStorage.setItem('cloudUser', JSON.stringify(data.user));
                    currentUser = data.user;
                    return { success: true };
                } else {
                    return { success: false, message: data.message };
                }
            } catch (error) {
                console.error('Cloud register error:', error);
                return { success: false, message: 'Network error' };
            }
        }

        // Authentication handlers
        async function handleLogin(e) {
            e.preventDefault();
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;

            if (USE_CLOUD) {
                const result = await cloudLogin(email, password);
                if (result.success) {
                    hideAuthModal();
                    loadUserNotes();
                    showToast('Login successful!', 'success');
                } else {
                    showToast(result.message, 'error');
                }
            } else {
                // localStorage fallback
                const users = JSON.parse(localStorage.getItem('users') || '[]');
                const user = users.find(u => u.email === email && u.password === password);

                if (user) {
                    currentUser = { id: user.id, username: user.username, email: user.email };
                    localStorage.setItem('currentUser', JSON.stringify(currentUser));
                    hideAuthModal();
                    loadUserNotes();
                    showToast('Login successful!', 'success');
                } else {
                    showToast('Invalid credentials', 'error');
                }
            }
        }

        async function handleRegister(e) {
            e.preventDefault();
            const username = document.getElementById('register-username').value;
            const email = document.getElementById('register-email').value;
            const password = document.getElementById('register-password').value;

            if (password.length < 6) {
                showToast('Password must be at least 6 characters long', 'error');
                return;
            }

            if (USE_CLOUD) {
                const result = await cloudRegister(username, email, password);
                if (result.success) {
                    hideAuthModal();
                    loadUserNotes();
                    showToast('Account created successfully!', 'success');
                } else {
                    showToast(result.message, 'error');
                }
            } else {
                // localStorage fallback
                const users = JSON.parse(localStorage.getItem('users') || '[]');
                
                if (users.find(u => u.username === username || u.email === email)) {
                    showToast('Username or email already exists', 'error');
                    return;
                }

                const newUser = {
                    id: Date.now().toString(),
                    username,
                    email,
                    password
                };

                users.push(newUser);
                localStorage.setItem('users', JSON.stringify(users));
                
                currentUser = { id: newUser.id, username: newUser.username, email: newUser.email };
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
                
                hideAuthModal();
                showToast('Account created successfully!', 'success');
            }
        }

        function handleLogout() {
            if (USE_CLOUD) {
                localStorage.removeItem('cloudToken');
                localStorage.removeItem('cloudUser');
            } else {
                localStorage.removeItem('currentUser');
            }
            
            // Clear saved page state for security
            localStorage.removeItem('youtubeNoteClipper_state');
            
            // Reset page to initial state
            resetPageToInitialState();
            
            // Hide auth modal and show login button
            hideAuthModal();
            
            showToast('Logged out successfully. Refreshing page to ensure clean state...', 'info');
            
            // Refresh the page after a short delay to ensure complete reset
            setTimeout(() => {
                window.location.reload();
            }, 1500);
        }

        // Core utility functions
        function getYouTubeVideoId(url) {
            const regExp = /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|\&v=)([^#\&\?]*).*/;
            const match = url.match(regExp);
            return (match && match[2].length === 11) ? match[2] : null;
        }

        // Load video function
        async function handleLoadVideo() {
            // SECURITY CHECK: Ensure user is authenticated before loading videos
            if (!currentUser) {
                showToast('Please log in to load videos', 'error');
                return;
            }
            
            const urlInput = document.getElementById('url-input');
            if (!urlInput || !urlInput.value.trim()) {
                showToast('Please enter a YouTube URL', 'error');
                return;
            }
            
            const videoId = getYouTubeVideoId(urlInput.value.trim());
            if (!videoId) {
                showToast('Please enter a valid YouTube URL', 'error');
                return;
            }
            
            // Stop any active loop when loading a new video
            if (typeof stopLoop === 'function') {
                stopLoop();
            }
            
            if (currentVideoId !== videoId) {
                currentVideoId = videoId;
                currentVideoTitle = await getVideoTitle(videoId);
                await loadVideoNotes(videoId);
                resetNoteTaker();
            }
            
            // Hide placeholder and show player
            if (playerPlaceholder) {
                playerPlaceholder.style.display = 'none';
            }
            
            // Load video in player
            if (typeof player !== 'undefined' && player && typeof player.loadVideoById === 'function') {
                player.loadVideoById(videoId);
            } else {
                // Create new player if it doesn't exist
                if (typeof YT !== 'undefined' && YT.Player) {
                    player = new YT.Player('player', {
                        videoId: videoId,
                        width: '100%',
                        height: '100%',
                        playerVars: { 
                            'playsinline': 1, 
                            'rel': 0,
                            'modestbranding': 1,
                            'showinfo': 0
                        },
                        events: { 'onPlayerReady': onPlayerReady }
                    });
                }
            }
            
            showToast(`Video loaded: ${currentVideoTitle}`, 'success');
            
            // Show video controls toolbar after video loads
            if (videoControlsToolbar) {
                videoControlsToolbar.classList.remove('hidden');
            }
            
            // Clear the URL input after loading
            if (urlInput) {
                urlInput.value = '';
            }
            
            // Save current page state
            savePageState();
        }

        // Enhanced video title fetching
        async function getVideoTitle(videoId) {
            try {
                const response = await fetch(`https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`);
                
                if (response.ok) {
                    const data = await response.json();
                    return data.title || `Video ${videoId}`;
                }
            } catch (error) {
                console.log('Could not fetch video title, using fallback');
            }
            
            return `Video ${videoId}`;
        }

        // Load video notes
        async function loadVideoNotes(videoId) {
            console.log('🔍 loadVideoNotes called with videoId:', videoId);
            
            // Check if user is authenticated via cloud or localStorage
            let user = currentUser;
            if (!user && USE_CLOUD) {
                const cloudUser = localStorage.getItem('cloudUser');
                if (cloudUser) {
                    user = JSON.parse(cloudUser);
                    currentUser = user; // Set currentUser for future use
                    console.log('✅ User authenticated via cloud:', user.username);
                }
            }
            if (!user) {
                const localUser = localStorage.getItem('currentUser');
                if (localUser) {
                    user = JSON.parse(localUser);
                    currentUser = user; // Set currentUser for future use
                    console.log('✅ User authenticated via localStorage:', user.username);
                }
            }
            
            if (!user) {
                console.log('❌ No user authenticated, cannot load video notes');
                return;
            }
            
            try {
                if (USE_CLOUD) {
                    const token = localStorage.getItem('cloudToken');
                    if (!token) {
                        console.log('No cloud token found');
                        return;
                    }
                    
                    const response = await fetch(`${API_BASE}/notes/video/${videoId}`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        notes = data.notes || [];
                        console.log('✅ Cloud notes loaded:', notes.length, 'notes');
                        console.log('📝 Notes data structure:', notes);
                        if (notes.length > 0) {
                            console.log('🔍 First note ID details:', {
                                id: notes[0].id,
                                _id: notes[0]._id,
                                hasOwnProperty_id: notes[0].hasOwnProperty('_id'),
                                hasOwnProperty_id: notes[0].hasOwnProperty('id')
                            });
                        }
                        console.log('🔍 Looking for videoId:', videoId);
                        console.log('📊 allNotes length:', allNotes ? allNotes.length : 'undefined');
                        renderCurrentVideoNotes();
                    } else {
                        console.log('❌ Failed to fetch cloud notes:', response.status);
                        // Fallback to using existing allNotes if available
                        if (allNotes && allNotes.length > 0) {
                            console.log('🔍 allNotes available, filtering for videoId:', videoId);
                            console.log('📊 allNotes sample:', allNotes.slice(0, 2));
                            notes = allNotes.filter(note => note.videoId === videoId);
                            console.log('✅ Using existing allNotes as fallback:', notes.length, 'notes');
                        } else {
                            console.log('❌ No allNotes available for fallback');
                            notes = [];
                        }
                        renderCurrentVideoNotes();
                    }
                } else {
                    // localStorage fallback
                    const userNotes = JSON.parse(localStorage.getItem(`notes_${user.id}`) || '[]');
                    console.log('🔍 localStorage userNotes:', userNotes.length, 'total notes');
                    console.log('🔍 Filtering for videoId:', videoId);
                    notes = userNotes.filter(note => note.videoId === videoId);
                    console.log('✅ localStorage notes loaded:', notes.length, 'notes for video', videoId);
                    renderCurrentVideoNotes();
                }
            } catch (error) {
                console.error('Failed to load video notes:', error);
                // Fallback to using existing allNotes if available
                if (allNotes && allNotes.length > 0) {
                    notes = allNotes.filter(note => note.videoId === videoId);
                    console.log('✅ Using existing allNotes as fallback after error:', notes.length, 'notes');
                } else {
                    notes = [];
                }
                renderCurrentVideoNotes();
            }
        }

        // Load user notes
        async function loadUserNotes() {
            // Check if user is authenticated via cloud or localStorage
            let user = currentUser;
            if (!user && USE_CLOUD) {
                const cloudUser = localStorage.getItem('cloudUser');
                if (cloudUser) {
                    user = JSON.parse(cloudUser);
                    currentUser = user; // Set currentUser for future use
                }
            }
            if (!user) {
                const localUser = localStorage.getItem('currentUser');
                if (localUser) {
                    user = JSON.parse(localUser);
                    currentUser = user; // Set currentUser for future use
                }
            }
            
            if (!user) {
                console.log('No user authenticated, clearing all notes for security');
                // SECURITY FIX: Clear all notes when no user is authenticated
                allNotes = [];
                notes = [];
                renderCurrentVideoNotes();
                renderAllNotesSidebar();
                updateUserProfile();
                return;
            }
            
            try {
                if (USE_CLOUD) {
                    const token = localStorage.getItem('cloudToken');
                    if (!token) {
                        console.log('No cloud token found');
                        return;
                    }
                    
                    const response = await fetch(`${API_BASE}/notes`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        allNotes = data.notes || [];
                        console.log('📊 Cloud notes loaded, checking ID format:');
                        if (allNotes.length > 0) {
                            console.log('📝 First note ID format:', {
                                id: allNotes[0].id,
                                _id: allNotes[0]._id,
                                hasOwnProperty_id: allNotes[0].hasOwnProperty('_id'),
                                hasOwnProperty_id: allNotes[0].hasOwnProperty('id')
                            });
                        }
                        
                        // Only filter notes if there's a current video selected
                        if (currentVideoId) {
                            notes = allNotes.filter(note => note.videoId === currentVideoId);
                        } else {
                            notes = []; // No video selected, so no notes to show
                        }
                        renderCurrentVideoNotes();
                        renderAllNotesSidebar();
                        updateUserProfile();
                    } else {
                        console.log('Failed to fetch cloud notes:', response.status);
                        allNotes = [];
                        notes = [];
                        renderCurrentVideoNotes();
                        renderAllNotesSidebar();
                        updateUserProfile();
                    }
                } else {
                    // localStorage fallback
                    const userNotes = JSON.parse(localStorage.getItem(`notes_${currentUser.id}`) || '[]');
                    allNotes = userNotes;
                    // Only filter notes if there's a current video selected
                    if (currentVideoId) {
                        notes = allNotes.filter(note => note.videoId === currentVideoId);
                    } else {
                        notes = []; // No video selected, so no notes to show
                    }
                    renderCurrentVideoNotes();
                    renderAllNotesSidebar();
                    updateUserProfile();
                }
            } catch (error) {
                console.error('Failed to load user notes:', error);
                allNotes = [];
                notes = [];
                renderCurrentVideoNotes();
                renderAllNotesSidebar();
                updateUserProfile();
            }
        }

        // Render current video notes
        function renderCurrentVideoNotes() {
            console.log('🔍 renderCurrentVideoNotes called');
            console.log('currentVideoId:', currentVideoId);
            console.log('notes array length:', notes ? notes.length : 'undefined');
            console.log('notes array:', notes);
            console.log('currentUser:', currentUser);
            
            // SECURITY CHECK: Ensure user is authenticated before rendering notes
            if (!currentUser) {
                console.log('🚨 Security: No authenticated user, clearing notes display');
                const container = document.getElementById('current-video-notes');
                if (container) {
                    container.innerHTML = '<p class="text-gray-500 text-center py-8">Please log in to view notes</p>';
                }
                return;
            }
            
            // Debug: Log the actual structure of each note
            if (notes && notes.length > 0) {
                console.log('🔍 Detailed notes structure:');
                notes.forEach((note, index) => {
                    console.log(`Note ${index}:`, {
                        id: note.id,
                        _id: note._id,
                        text: note.text,
                        videoId: note.videoId,
                        startTime: note.startTime,
                        endTime: note.endTime
                    });
                });
            }
            
            const container = document.getElementById('current-video-notes');
            if (!container) {
                console.log('❌ current-video-notes container not found');
                return;
            }
            
            if (!currentVideoId) {
                console.log('❌ No currentVideoId');
                container.innerHTML = '<p class="text-gray-500 text-center py-8">No video loaded</p>';
                return;
            }
            
            if (notes.length === 0) {
                console.log('❌ No notes found for video:', currentVideoId);
                console.log('🔍 Checking allNotes for this video...');
                if (allNotes && allNotes.length > 0) {
                    const availableNotes = allNotes.filter(note => note.videoId === currentVideoId);
                    console.log('📊 Found', availableNotes.length, 'notes in allNotes for video', currentVideoId);
                    if (availableNotes.length > 0) {
                        console.log('⚠️ Notes exist in allNotes but not in notes array - this is a bug!');
                        console.log('📝 Available notes:', availableNotes);
                    }
                }
                container.innerHTML = '<p class="text-gray-500 text-center py-8">No notes for this video yet</p>';
                return;
            }
            
            let notesHTML = '';
            notes.forEach((note, index) => {
                const noteId = NoteIdManager.getPrimaryId(note);
                console.log(`Rendering note ${index}:`, note);
                console.log(`📝 Note ID for rendering: ${noteId}`);
                console.log(`🔍 Note object details:`, {
                    id: note.id,
                    _id: note._id,
                    text: note.text,
                    videoId: note.videoId
                });
                notesHTML += `
                    <div class="bg-gray-50 p-3 rounded-lg border" data-note-id="${noteId}">
                        <div class="flex justify-between items-start mb-2">
                            <span class="font-mono text-sm text-blue-600 note-time-display" data-note-id="${noteId}">${formatTime(note.startTime)} → ${formatTime(note.endTime)}</span>
                            <button onclick="deleteNote('${noteId}')" class="text-red-500 hover:text-red-700 text-sm">×</button>
                        </div>
                        <div class="note-content">
                            <p class="text-gray-700 text-sm note-text" data-note-id="${noteId}">${escapeHTML(note.text)}</p>
                            <div class="note-edit hidden" data-note-id="${noteId}">
                                <div class="space-y-3">
                                    <div>
                                        <label class="block text-xs text-gray-600 mb-1">Start Time (seconds)</label>
                                        <input type="number" name="startTime" step="0.1" min="0" value="${note.startTime}" class="w-full p-2 border border-gray-300 rounded text-sm">
                                    </div>
                                    <div>
                                        <label class="block text-xs text-gray-600 mb-1">End Time (seconds)</label>
                                        <input type="number" name="endTime" step="0.1" min="0" value="${note.endTime}" class="w-full p-2 border border-gray-300 rounded text-sm">
                                    </div>
                                    <div>
                                        <label class="block text-xs text-gray-600 mb-1">Note Text</label>
                                        <textarea class="w-full p-2 border border-gray-300 rounded text-sm" rows="2">${escapeHTML(note.text)}</textarea>
                                    </div>
                                    <div class="flex space-x-2">
                                        <button onclick="saveNoteEdit('${noteId}')" class="text-xs bg-green-500 text-white py-1 px-2 rounded hover:bg-green-600 transition">Save</button>
                                        <button onclick="cancelNoteEdit('${noteId}')" class="text-xs bg-gray-500 text-white py-1 px-2 rounded hover:bg-gray-600 transition">Cancel</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="flex space-x-2 mt-2">
                            <button onclick="seekToTime(${note.startTime})" class="text-xs bg-blue-100 text-blue-700 py-1 px-2 rounded hover:bg-blue-200 transition">
                                Go to Start
                            </button>
                            <button onclick="stopLoop()" class="text-xs bg-red-100 text-red-700 py-1 px-2 rounded hover:bg-red-200 transition hidden" id="stop-loop-${noteId}">
                                Stop Loop
                            </button>
                            <button onclick="playClip(${note.startTime}, ${note.endTime}, '${noteId}')" class="text-xs bg-green-100 text-green-700 py-1 px-2 rounded hover:bg-green-200 transition">
                                Play Clip
                            </button>
                            <button onclick="editNote('${noteId}')" class="text-xs bg-yellow-100 text-yellow-700 py-1 px-2 rounded hover:bg-yellow-200 transition">
                                Edit
                            </button>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = notesHTML;
        }

        // Add note function
        async function handleAddNote() {
            console.log('🔍 handleAddNote called');
            
            if (!currentUser) {
                showToast('Please login first', 'error');
                return;
            }

            if (!currentVideoId) {
                showToast('Please load a video first', 'error');
                return;
            }

            const text = noteText.value.trim();
            if (!text) {
                showToast('Please enter note text', 'error');
                return;
            }

            if (tempStartTime === 0 || tempEndTime === 0) {
                showToast('Please set both start and end times first', 'error');
                return;
            }

            if (tempStartTime >= tempEndTime) {
                showToast('Start time must be before end time', 'error');
                return;
            }

            // Use current video info
            const note = {
                videoId: currentVideoId,
                videoTitle: currentVideoTitle,
                startTime: tempStartTime,
                endTime: tempEndTime,
                text: text.trim()
            };

            try {
                if (USE_CLOUD) {
                    const token = localStorage.getItem('cloudToken');
                    const response = await fetch(`${API_BASE}/notes`, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify(note)
                    });

                    if (response.ok) {
                        const data = await response.json();
                        notes.push(data.note);
                        allNotes.push(data.note);

            // Clear form
            noteText.value = '';
            tempStartTime = 0;
            tempEndTime = 0;
                        if (toolbarStartTime) toolbarStartTime.textContent = '00:00';
                        if (toolbarEndTime) toolbarEndTime.textContent = '00:00';

            // Update displays
            renderCurrentVideoNotes();
            renderAllNotesSidebar();
            updateUserProfile();

            showToast('Note added successfully!', 'success');
                        
                        // Save current page state
                        savePageState();
                    } else {
                        showToast('Failed to save note', 'error');
        }
                } else {
                    // localStorage fallback
                    note.id = Date.now().toString();
                    note.userId = currentUser.id;
                    note.createdAt = new Date().toISOString();

                    notes.push(note);
                    allNotes.push(note);
            
                    // Save to localStorage
                const userNotes = JSON.parse(localStorage.getItem(`notes_${currentUser.id}`) || '[]');
                    userNotes.push(note);
                    localStorage.setItem(`notes_${currentUser.id}`, JSON.stringify(userNotes));
                    
                    // Clear form
                    noteText.value = '';
                    tempStartTime = 0;
                    tempEndTime = 0;
                    if (toolbarStartTime) toolbarStartTime.textContent = '00:00';
                    if (toolbarEndTime) toolbarEndTime.textContent = '00:00';
                    
                    // Update displays
                    renderCurrentVideoNotes();
                renderAllNotesSidebar();
                    updateUserProfile();
                    
                    showToast('Note added successfully!', 'success');
                    
                    // Save current page state
                    savePageState();
                }
            } catch (error) {
                console.error('Error adding note:', error);
                showToast('Failed to save note', 'error');
            }
        }
        
        // Update user profile
        function updateUserProfile() {
            if (!currentUser) return;
            
            // Update profile display
            const profileUsername = document.getElementById('profile-username');
            const profileEmail = document.getElementById('profile-email');
            const userAvatar = document.getElementById('user-avatar');
            
            if (profileUsername) profileUsername.textContent = currentUser.username;
            if (profileEmail) profileEmail.textContent = currentUser.email;
            if (userAvatar) userAvatar.textContent = currentUser.username.charAt(0).toUpperCase();
            
            // Update stats
            const totalNotes = allNotes.length;
            const uniqueVideos = [...new Set(allNotes.map(note => note.videoId))].length;
            
            const totalNotesElement = document.getElementById('total-notes');
            const totalVideosElement = document.getElementById('total-videos');
            
            if (totalNotesElement) totalNotesElement.textContent = totalNotes;
            if (totalVideosElement) totalVideosElement.textContent = uniqueVideos;
            
            console.log('✅ User profile updated:', {
                username: currentUser.username,
                email: currentUser.email,
                totalNotes,
                uniqueVideos
            });
        }

        // Render all notes sidebar
        function renderAllNotesSidebar() {
            console.log('🔍 renderAllNotesSidebar called');
            console.log('allNotes length:', allNotes.length);
            console.log('allNotes sample:', allNotes.slice(0, 2));
            
            // SECURITY CHECK: Ensure user is authenticated before rendering notes
            if (!currentUser) {
                console.log('🚨 Security: No authenticated user, clearing sidebar');
                const container = document.getElementById('all-notes-sidebar');
                if (container) {
                    container.innerHTML = '<p class="text-gray-500 text-center py-6 text-sm">Please log in to view notes</p>';
                }
                return;
            }
            
            const container = document.getElementById('all-notes-sidebar');
            if (!container) return;
            
            if (allNotes.length === 0) {
                container.innerHTML = '<p class="text-gray-500 text-center py-6 text-sm">No notes yet</p>';
                return;
            }
            
            // Group notes by video
            const videoGroups = {};
            console.log('🔍 Grouping notes by video...');
            allNotes.forEach(note => {
                console.log('📝 Processing note:', { videoId: note.videoId, title: note.videoTitle });
                if (!videoGroups[note.videoId]) {
                    videoGroups[note.videoId] = [];
                }
                videoGroups[note.videoId].push(note);
            });
            console.log('📊 Video groups created:', Object.keys(videoGroups));
            
            let sidebarHTML = '';
            Object.entries(videoGroups).forEach(([videoId, videoNotes]) => {
                const videoTitle = videoNotes[0].videoTitle;
                const noteCount = videoNotes.length;
                
                console.log(`📊 Rendering video group: ${videoId} with ${noteCount} notes`);
                
                sidebarHTML += `
                    <div class="bg-gray-50 p-3 rounded-lg border">
                        <h4 class="font-semibold text-sm text-gray-800 mb-2">${escapeHTML(videoTitle)}</h4>
                        <div class="flex items-center justify-between">
                            <span class="text-xs text-gray-600">${noteCount} note${noteCount > 1 ? 's' : ''}</span>
                            <button onclick="loadVideoById('${videoId}')" class="bg-blue-500 text-white text-xs py-1 px-2 rounded hover:bg-blue-600 transition">
                                View Note
                            </button>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = sidebarHTML;
        }

        // Load video by ID
        async function loadVideoById(videoId) {
            console.log('🔍 loadVideoById called with videoId:', videoId);
            
            // SECURITY CHECK: Ensure user is authenticated before loading video notes
            if (!currentUser) {
                console.log('🚨 Security: No authenticated user, cannot load video notes');
                showToast('Please log in to view notes', 'error');
                return;
            }
            
            // Stop any active loop when loading a new video
            if (typeof stopLoop === 'function') {
                stopLoop();
            }
            
            currentVideoId = videoId;
            
            // Get video title from existing notes
            const videoNotes = allNotes.filter(note => note.videoId === videoId);
            if (videoNotes.length > 0) {
                currentVideoTitle = videoNotes[0].videoTitle;
                console.log('Using existing video title:', currentVideoTitle);
            } else {
                // Fallback to fetching title
                currentVideoTitle = await getVideoTitle(videoId);
                console.log('Fetched video title:', currentVideoTitle);
            }
            
            // Check if notes are already available in allNotes
            if (allNotes && allNotes.length > 0) {
                const existingNotes = allNotes.filter(note => note.videoId === videoId);
                if (existingNotes.length > 0) {
                    notes = existingNotes;
                    console.log('✅ Using existing notes from allNotes:', notes.length, 'notes');
                    renderCurrentVideoNotes();
                } else {
                    // Load notes for this video if not found in allNotes
                    await loadVideoNotes(videoId);
                }
            } else {
                // Load notes for this video
                await loadVideoNotes(videoId);
            }
            
            // Reset note input only (don't hide video controls)
            if (noteText) noteText.value = '';
            if (toolbarStartTime) toolbarStartTime.textContent = '00:00';
            if (toolbarEndTime) toolbarEndTime.textContent = '00:00';
            tempStartTime = 0;
            tempEndTime = 0;
            
            // Hide placeholder and show player
            if (playerPlaceholder) {
                playerPlaceholder.style.display = 'none';
            }
            
            // Load video in player
            if (typeof player !== 'undefined' && player && typeof player.loadVideoById === 'function') {
                player.loadVideoById(videoId);
                console.log('✅ Video loaded in existing player');
            } else {
                // Create new player if it doesn't exist
                if (typeof YT !== 'undefined' && YT.Player) {
                    player = new YT.Player('player', {
                        videoId: videoId,
                        width: '100%',
                        height: '100%',
                        playerVars: { 
                            'playsinline': 1, 
                            'rel': 0,
                            'modestbranding': 1,
                            'showinfo': 0
                        },
                        events: { 'onPlayerReady': onPlayerReady }
                    });
                    console.log('✅ New player created');
                }
            }
            
            // Show video controls toolbar
            if (videoControlsToolbar) {
                videoControlsToolbar.classList.remove('hidden');
            }
            
            // Save current page state
            savePageState();
            
            showToast(`Video loaded: ${currentVideoTitle}`, 'success');
        }

        // Debug function to manually refresh notes display
        window.debugRefreshNotes = function() {
            console.log('🔍 Debug: Manually refreshing notes display');
            console.log('currentVideoId:', currentVideoId);
            console.log('allNotes length:', allNotes ? allNotes.length : 'undefined');
            console.log('notes length:', notes ? notes.length : 'undefined');
            
            if (currentVideoId && allNotes && allNotes.length > 0) {
                const availableNotes = allNotes.filter(note => note.videoId === currentVideoId);
                console.log('📊 Available notes for current video:', availableNotes.length);
                if (availableNotes.length > 0) {
                    notes = availableNotes;
                    console.log('✅ Manually set notes array');
                    renderCurrentVideoNotes();
                }
            }
        }
        
        // Debug function to check current notes state
        window.debugNotesState = function() {
            console.log('🔍 Debug: Current notes state');
            console.log('allNotes:', allNotes);
            console.log('notes:', notes);
            console.log('currentVideoId:', currentVideoId);
            
            if (allNotes && allNotes.length > 0) {
                console.log('📊 Notes by video:');
                const videoGroups = {};
                allNotes.forEach(note => {
                    if (!videoGroups[note.videoId]) {
                        videoGroups[note.videoId] = [];
                    }
                    videoGroups[note.videoId].push(note);
                });
                
                Object.entries(videoGroups).forEach(([videoId, videoNotes]) => {
                    console.log(`  ${videoId}: ${videoNotes.length} notes`);
                });
            }
        }
        
        // Unified ID handling system - eliminates all id/_id compatibility issues
        const NoteIdManager = {
            // Get the primary ID from a note object (prefer _id, fallback to id)
            getPrimaryId: function(note) {
                if (!note) return null;
                return note._id || note.id || null;
            },
            
            // Check if two IDs match (handles string/number conversion)
            idsMatch: function(id1, id2) {
                if (id1 === id2) return true;
                if (id1 == id2) return true; // Loose equality for string/number
                if (String(id1) === String(id2)) return true;
                if (Number(id1) === Number(id2)) return true;
                return false;
            },
            
            // Find a note by ID in any array
            findNoteById: function(noteId, notesArray) {
                if (!noteId || !notesArray || !Array.isArray(notesArray)) return null;
                return notesArray.find(note => this.idsMatch(this.getPrimaryId(note), noteId));
            },
            
            // Find notes by ID in multiple arrays
            findNoteInArrays: function(noteId, ...arrays) {
                for (const array of arrays) {
                    if (array && Array.isArray(array)) {
                        const note = this.findNoteById(noteId, array);
                        if (note) return note;
                    }
                }
                return null;
            },
            
            // Normalize ID for consistent comparison
            normalizeId: function(id) {
                if (id === null || id === undefined) return null;
                // Try to convert to number first, then string
                const numId = Number(id);
                if (!isNaN(numId) && isFinite(numId)) return numId;
                return String(id);
            }
        };
        
        // Legacy compatibility function (deprecated - use NoteIdManager instead)
        function getNoteId(note) {
            console.warn('⚠️ getNoteId is deprecated. Use NoteIdManager.getPrimaryId() instead.');
            return NoteIdManager.getPrimaryId(note);
        }
        
        // Debug function to test note editing functionality
        window.debugNoteEditing = function() {
            console.log('🔍 Debug: Testing note editing functionality');
            
            if (!currentVideoId || notes.length === 0) {
                console.log('❌ No current video or notes to test editing');
                return;
            }
            
            const firstNote = notes[0];
            console.log('📝 Testing with first note:', {
                id: firstNote.id,
                _id: firstNote._id,
                text: firstNote.text,
                startTime: firstNote.startTime,
                endTime: firstNote.endTime
            });
            
            // Test entering edit mode
            console.log('🔧 Entering edit mode...');
            editNote(firstNote.id || firstNote._id);
            
            // Check if edit form is visible
            setTimeout(() => {
                const noteEdit = document.querySelector(`.note-edit[data-note-id="${firstNote.id || firstNote._id}"]`);
                if (noteEdit && !noteEdit.classList.contains('hidden')) {
                    console.log('✅ Edit form is visible');
                    
                    // Test form inputs
                    const textarea = noteEdit.querySelector('textarea');
                    const startTimeInput = noteEdit.querySelector('input[name="startTime"]');
                    const endTimeInput = noteEdit.querySelector('input[name="endTime"]');
                    
                    console.log('📝 Form inputs found:', {
                        textarea: !!textarea,
                        startTimeInput: !!startTimeInput,
                        endTimeInput: !!endTimeInput
                    });
                    
                    if (textarea && startTimeInput && endTimeInput) {
                        console.log('✅ All form inputs are present and functional');
                    } else {
                        console.error('❌ Some form inputs are missing');
                    }
                } else {
                    console.error('❌ Edit form is not visible');
                }
            }, 100);
        }

        // Note editing functions
        window.editNote = function(noteId) {
            console.log('🔍 editNote called with noteId:', noteId);
            console.log('📊 Current notes array:', notes);
            console.log('📊 Current allNotes array:', allNotes);
            console.log('🔍 Looking for note with ID:', noteId);
            
            if (!noteId) {
                console.error('❌ No noteId provided to editNote');
                showToast('Invalid note ID for editing', 'error');
                return;
            }
            
            console.log('🔍 Using NoteIdManager to find note with ID:', noteId);
            
            // Use the unified ID manager to find the note
            let note = NoteIdManager.findNoteInArrays(noteId, notes, allNotes);
            
            if (note) {
                console.log('✅ Note found using NoteIdManager:', {
                    id: note.id,
                    _id: note._id,
                    text: note.text
                });
                
                // If note was found in allNotes but not in notes, add it
                if (!notes.includes(note)) {
                    console.log('✅ Adding note from allNotes to current notes');
                    notes.push(note);
                }
            } else {
                console.log('❌ Note not found using NoteIdManager');
            }
            
            if (!note) {
                console.error('❌ Note not found in any data for noteId:', noteId);
                console.log('❌ Available note IDs in notes array:', notes.map(n => ({ id: n.id, _id: n._id })));
                console.log('❌ Available note IDs in allNotes array:', allNotes.map(n => ({ id: n.id, _id: n._id })));
                showToast('Note data not found', 'error');
                return;
            }
            
            const noteText = document.querySelector(`.note-text[data-note-id="${noteId}"]`);
            const noteEdit = document.querySelector(`.note-edit[data-note-id="${noteId}"]`);
            
            console.log('🔍 DOM elements found:', {
                noteText: !!noteText,
                noteEdit: !!noteEdit,
                noteTextSelector: `.note-text[data-note-id="${noteId}"]`,
                noteEditSelector: `.note-edit[data-note-id="${noteId}"]`
            });
            
            if (!noteText || !noteEdit) {
                console.error('❌ Note elements not found for noteId:', noteId);
                console.log('noteText found:', !!noteText);
                console.log('noteEdit found:', !!noteEdit);
                
                // Debug: Check all elements with data-note-id
                const allNoteElements = document.querySelectorAll('[data-note-id]');
                console.log('🔍 All elements with data-note-id:', Array.from(allNoteElements).map(el => ({
                    tagName: el.tagName,
                    className: el.className,
                    dataNoteId: el.getAttribute('data-note-id')
                })));
                
                showToast('Note edit form not found', 'error');
                return;
            }
            
            console.log('✅ Entering edit mode for note:', {
                id: note.id,
                _id: note._id,
                text: note.text,
                startTime: note.startTime,
                endTime: note.endTime
            });
            
            noteText.classList.add('hidden');
            noteEdit.classList.remove('hidden');
            
            // Focus on the textarea
            const textarea = noteEdit.querySelector('textarea');
            if (textarea) {
                textarea.focus();
                textarea.select();
                console.log('✅ Textarea focused and text selected');
            } else {
                console.error('❌ Textarea not found in edit form');
            }
        }
        
        window.cancelNoteEdit = function(noteId) {
            console.log('🔍 cancelNoteEdit called with noteId:', noteId);
            
            const noteText = document.querySelector(`.note-text[data-note-id="${noteId}"]`);
            const noteEdit = document.querySelector(`.note-edit[data-note-id="${noteId}"]`);
            
            if (noteText && noteEdit) {
                noteText.classList.remove('hidden');
                noteEdit.classList.add('hidden');
                
                // Reset the form inputs to original values using NoteIdManager
                const note = NoteIdManager.findNoteById(noteId, notes);
                if (note) {
                    const startTimeInput = noteEdit.querySelector('input[name="startTime"]');
                    const endTimeInput = noteEdit.querySelector('input[name="endTime"]');
                    const textarea = noteEdit.querySelector('textarea');
                    
                    if (startTimeInput) startTimeInput.value = note.startTime;
                    if (endTimeInput) endTimeInput.value = note.endTime;
                    if (textarea) textarea.value = note.text;
                    
                    console.log('✅ Note edit cancelled and form reset');
                } else {
                    console.error('❌ Note not found for reset in cancelNoteEdit');
                }
            } else {
                console.error('❌ Note edit elements not found for noteId:', noteId);
            }
        }
        
        window.saveNoteEdit = async function(noteId) {
            console.log('🔍 saveNoteEdit called with noteId:', noteId);
            
            const noteEdit = document.querySelector(`.note-edit[data-note-id="${noteId}"]`);
            if (!noteEdit) {
                console.error('❌ Note edit form not found for noteId:', noteId);
                showToast('Note edit form not found', 'error');
                return;
            }
            
            const textarea = noteEdit?.querySelector('textarea');
            const startTimeInput = noteEdit?.querySelector('input[name="startTime"]');
            const endTimeInput = noteEdit?.querySelector('input[name="endTime"]');
            
            if (!textarea) {
                console.error('❌ Textarea not found in note edit form');
                showToast('Note edit form is incomplete', 'error');
                return;
            }
            
            const newText = textarea.value.trim();
            if (!newText) {
                showToast('Note text cannot be empty', 'error');
                return;
            }
            
            // Parse time inputs with validation
            let newStartTime = 0;
            let newEndTime = 0;
            
            if (startTimeInput && endTimeInput) {
                newStartTime = parseFloat(startTimeInput.value);
                newEndTime = parseFloat(endTimeInput.value);
                
                // Validate time values
                if (isNaN(newStartTime) || isNaN(newEndTime)) {
                    showToast('Please enter valid time values', 'error');
                    return;
                }
                
                if (newStartTime < 0 || newEndTime < 0) {
                    showToast('Time values cannot be negative', 'error');
                    return;
                }
                
                if (newStartTime >= newEndTime) {
                    showToast('End time must be greater than start time', 'error');
                    return;
                }
            }
            
            console.log('📝 Updating note with data:', {
                noteId,
                newText,
                newStartTime,
                newEndTime
            });
            
            try {
                if (USE_CLOUD) {
                    const token = localStorage.getItem('cloudToken');
                    if (!token) {
                        showToast('Authentication token not found', 'error');
                        return;
                    }
                    
                    // Use the unified ID manager to find the note
                    const note = NoteIdManager.findNoteInArrays(noteId, notes, allNotes);
                    
                    if (!note) {
                        console.error('❌ Note not found for editing:', noteId);
                        console.log('🔍 Search details:', {
                            noteId,
                            availableIds: notes.map(n => ({ id: n.id, _id: n._id }))
                        });
                        showToast('Note not found for editing', 'error');
                        return;
                    }
                    
                    // Use the correct ID format (prefer _id if available)
                    const actualNoteId = note._id || note.id || noteId;
                    
                    console.log('🔍 Sending update request for note:', actualNoteId);
                    
                    const response = await fetch(`${API_BASE}/notes/${actualNoteId}`, {
                        method: 'PUT',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify({ 
                            text: newText,
                            startTime: newStartTime,
                            endTime: newEndTime
                        })
                    });
                    
                    console.log('📡 Update response status:', response.status);
                    
                    if (response.ok) {
                        const responseData = await response.json();
                        console.log('✅ Note updated successfully:', responseData);
                        
                        // Update local note arrays using NoteIdManager
                        if (note) {
                            note.text = newText;
                            note.startTime = newStartTime;
                            note.endTime = newEndTime;
                            console.log('✅ Updated note in notes array');
                        }
                        
                        // Also update the note in allNotes array
                        const allNote = NoteIdManager.findNoteById(noteId, allNotes);
                        if (allNote) {
                            allNote.text = newText;
                            allNote.startTime = newStartTime;
                            allNote.endTime = newEndTime;
                            console.log('✅ Updated note in allNotes array');
                        }
                        
                        // Exit edit mode
                        cancelNoteEdit(noteId);
                        
                        // Update displays
                        renderCurrentVideoNotes();
                        renderAllNotesSidebar();
                        updateUserProfile();
                        showToast('Note updated successfully!', 'success');
                        
                        // Save current page state
                        savePageState();
                    } else {
                        let errorMessage = 'Server error';
                        try {
                            const errorData = await response.json();
                            errorMessage = errorData.message || errorData.error || 'Server error';
                            console.error('❌ Server error details:', errorData);
                        } catch (parseError) {
                            console.error('❌ Failed to parse error response:', parseError);
                        }
                        
                        console.error('❌ Failed to update note. Status:', response.status);
                        showToast(`Failed to update note: ${errorMessage}`, 'error');
                    }
                } else {
                    // localStorage fallback
                    console.log('📝 Using localStorage fallback for note update');
                    
                    // Find notes using NoteIdManager
                    const note = NoteIdManager.findNoteById(noteId, notes);
                    const allNote = NoteIdManager.findNoteById(noteId, allNotes);
                    
                    if (note) {
                        note.text = newText;
                        note.startTime = newStartTime;
                        note.endTime = newEndTime;
                        console.log('✅ Updated note in notes array');
                    } else {
                        console.error('❌ Note not found in notes array for localStorage update');
                    }
                    
                    if (allNote) {
                        allNote.text = newText;
                        allNote.startTime = newStartTime;
                        allNote.endTime = newEndTime;
                        console.log('✅ Updated note in allNotes array');
                    } else {
                        console.error('❌ Note not found in allNotes array for localStorage update');
                    }
                    
                    // Update localStorage using NoteIdManager
                    const userNotes = JSON.parse(localStorage.getItem(`notes_${currentUser.id}`) || '[]');
                    const noteIndex = userNotes.findIndex(n => NoteIdManager.idsMatch(NoteIdManager.getPrimaryId(n), noteId));
                    
                    if (noteIndex !== -1) {
                        userNotes[noteIndex].text = newText;
                        userNotes[noteIndex].startTime = newStartTime;
                        userNotes[noteIndex].endTime = newEndTime;
                        localStorage.setItem(`notes_${currentUser.id}`, JSON.stringify(userNotes));
                        console.log('✅ Updated note in localStorage');
                    } else {
                        console.error('❌ Note not found in localStorage for update');
                    }
                    
                    // Exit edit mode
                    cancelNoteEdit(noteId);
                    
                    // Update displays
                    renderCurrentVideoNotes();
                    renderAllNotesSidebar();
                    updateUserProfile();
                    showToast('Note updated successfully!', 'success');
                    
                    // Save current page state
                    savePageState();
                }
            } catch (error) {
                console.error('Error updating note:', error);
                showToast('Failed to update note. Please try again.', 'error');
            }
        }
        
        // Delete note function
        window.deleteNote = async function(noteId) {
            console.log('🔍 deleteNote called with noteId:', noteId);
            console.log('Current user:', currentUser);
            
            if (!currentUser) {
                showToast("Please log in to delete notes.", 'error');
                return;
            }

            try {
                if (USE_CLOUD) {
                    const token = localStorage.getItem('cloudToken');
                    const response = await fetch(`${API_BASE}/notes/${noteId}`, {
                        method: 'DELETE',
                        headers: { 'Authorization': `Bearer ${token}` }
                    });

                    if (response.ok) {
                        // Remove note from both arrays
                        const initialNotesCount = notes.length;
                        const initialAllNotesCount = allNotes.length;
                        
                        console.log('🔍 Before deletion - searching for note with ID:', noteId);
                        console.log('📝 Notes array before deletion:', notes.map(n => ({ id: n.id, _id: n._id, videoId: n.videoId })));
                        console.log('📊 AllNotes array before deletion:', allNotes.map(n => ({ id: n.id, _id: n._id, videoId: n.videoId })));
                        
                        // Use NoteIdManager for consistent ID handling
                        notes = notes.filter(note => !NoteIdManager.idsMatch(NoteIdManager.getPrimaryId(note), noteId));
                        allNotes = allNotes.filter(note => !NoteIdManager.idsMatch(NoteIdManager.getPrimaryId(note), noteId));
                        
                        console.log(`Note deletion: Removed note ${noteId}`);
                        console.log(`Notes: ${initialNotesCount} → ${notes.length}`);
                        console.log(`All Notes: ${initialAllNotesCount} → ${allNotes.length}`);
                        
                        // Update displays
                        renderCurrentVideoNotes();
                        renderAllNotesSidebar();
                        updateUserProfile();
                        
                        // Check if current video still has notes
                        if (currentVideoId) {
                            const remainingNotes = allNotes.filter(note => note.videoId === currentVideoId);
                            console.log(`📊 After deletion: ${remainingNotes.length} notes remaining for current video ${currentVideoId}`);
                        }
                        
                        // Force a small delay to ensure DOM updates are processed
                        setTimeout(() => {
                            console.log('🔄 Force refreshing displays after deletion...');
                            renderAllNotesSidebar();
                            updateUserProfile();
                        }, 100);
                        
                        // Save current page state
                        savePageState();
                        
                        showToast('Note deleted successfully!', 'success');
                    } else {
                        showToast('Failed to delete note', 'error');
                    }
                } else {
                    // localStorage fallback
                const initialNotesCount = notes.length;
                const initialAllNotesCount = allNotes.length;
                
                console.log('🔍 Before deletion (localStorage) - searching for note with ID:', noteId);
                console.log('📝 Notes array before deletion:', notes.map(n => ({ id: n.id, _id: n._id, videoId: n.videoId })));
                console.log('📊 AllNotes array before deletion:', allNotes.map(n => ({ id: n.id, _id: n._id, videoId: n.videoId })));
                
                // Use NoteIdManager for consistent ID handling
                notes = notes.filter(note => !NoteIdManager.idsMatch(NoteIdManager.getPrimaryId(note), noteId));
                allNotes = allNotes.filter(note => !NoteIdManager.idsMatch(NoteIdManager.getPrimaryId(note), noteId));
                
                console.log(`Note deletion (localStorage): Removed note ${noteId}`);
                console.log(`Notes: ${initialNotesCount} → ${notes.length}`);
                console.log(`All Notes: ${initialAllNotesCount} → ${allNotes.length}`);
                
                // Update localStorage
                const userNotes = JSON.parse(localStorage.getItem(`notes_${currentUser.id}`) || '[]');
                const updatedNotes = userNotes.filter(note => !NoteIdManager.idsMatch(NoteIdManager.getPrimaryId(note), noteId));
                localStorage.setItem(`notes_${currentUser.id}`, JSON.stringify(updatedNotes));
                
                // Update displays
                renderCurrentVideoNotes();
                renderAllNotesSidebar();
                updateUserProfile();
                
                // Check if current video still has notes
                if (currentVideoId) {
                    const remainingNotes = allNotes.filter(note => note.videoId === currentVideoId);
                    console.log(`📊 After deletion (localStorage): ${remainingNotes.length} notes remaining for current video ${currentVideoId}`);
                }
                
                // Force a small delay to ensure DOM updates are processed
                setTimeout(() => {
                    console.log('🔄 Force refreshing displays after deletion (localStorage)...');
                    renderAllNotesSidebar();
                    updateUserProfile();
                }, 100);
                
                // Save current page state
                savePageState();
                
                showToast('Note deleted successfully!', 'success');
                }
            } catch (error) {
                console.error('Error deleting note:', error);
                showToast('Failed to delete note. Please try again.', 'error');
            }
        }

        // Helper functions for video controls
        window.seekToTime = function(time) {
            if (player && typeof player.seekTo === 'function') {
                player.seekTo(time);
                showToast(`Seeking to ${formatTime(time)}`, 'info');
            }
        }
        
        window.playClip = function(startTime, endTime, noteId = null) {
            if (player && typeof player.seekTo === 'function') {
                player.seekTo(startTime);
                player.playVideo();
                
                // Set up loop for this clip
                stopLoop();
                startLoop(startTime, endTime, -1, noteId);
                showToast(`Playing clip from ${formatTime(startTime)} to ${formatTime(endTime)}`, 'info');
            }
        }

        window.startLoop = function(startTime, endTime, index, noteId = null) {
            if (!player || typeof player.seekTo !== 'function') return;
            stopLoop();
            loopingNoteIndex = index;
            player.seekTo(startTime);
            player.playVideo();

            // Show stop looping button (old)
            if (stopLoopingBtn) {
                stopLoopingBtn.classList.remove('hidden');
            }
            
            // Update looping status (old)
            if (loopingStatus) {
                loopingStatus.textContent = `(${formatTime(startTime)} → ${formatTime(endTime)})`;
            }
            
            // Show stop loop button for specific note if noteId is provided
            if (noteId) {
                const stopLoopBtn = document.getElementById(`stop-loop-${noteId}`);
                if (stopLoopBtn) {
                    stopLoopBtn.classList.remove('hidden');
                }
            }
            
            // Show toolbar stop looping button
            if (toolbarStopLooping) {
                toolbarStopLooping.classList.remove('hidden');
            }
            
            // Update toolbar looping status
            if (toolbarLoopingStatus) {
                toolbarLoopingStatus.textContent = `(${formatTime(startTime)} → ${formatTime(endTime)})`;
            }

            loopInterval = setInterval(() => {
                if (player && typeof player.getCurrentTime === 'function') {
                    const currentTime = player.getCurrentTime();
                    if (currentTime >= endTime || currentTime < startTime) {
                        player.seekTo(startTime);
                    }
                }
            }, 250);
        }

        window.stopLoop = function() {
            if (loopInterval) {
                clearInterval(loopInterval);
                loopInterval = null;
            }
            loopingNoteIndex = -1;
            
            // Hide stop looping button (old)
            if (stopLoopingBtn) {
                stopLoopingBtn.classList.add('hidden');
            }
            
            // Clear looping status (old)
            if (loopingStatus) {
                loopingStatus.textContent = '';
            }
            
            // Hide toolbar stop looping button
            if (toolbarStopLooping) {
                toolbarStopLooping.classList.add('hidden');
            }
            
            // Clear toolbar looping status
            if (toolbarLoopingStatus) {
                toolbarLoopingStatus.textContent = '';
            }
            
            // Hide all note-specific stop loop buttons
            const allStopLoopBtns = document.querySelectorAll('[id^="stop-loop-"]');
            allStopLoopBtns.forEach(btn => {
                btn.classList.add('hidden');
            });
        }

        // Set time functions
        function setTime(type) {
            console.log('🔍 setTime called with type:', type);
            if (typeof player !== 'undefined' && player && typeof player.getCurrentTime === 'function') {
                const currentTime = Math.floor(player.getCurrentTime());
                console.log('Current player time:', currentTime);
                
                if (type === 'start') {
                    tempStartTime = currentTime;
                    console.log('Set start time to:', tempStartTime);
                    if (toolbarStartTime) {
                        toolbarStartTime.textContent = formatTime(currentTime);
                        console.log('Updated toolbar start time display');
                    }
                } else {
                    tempEndTime = currentTime;
                    console.log('Set end time to:', tempEndTime);
                    if (toolbarEndTime) {
                        toolbarEndTime.textContent = formatTime(currentTime);
                        console.log('Updated toolbar end time display');
                }
                }
                
                // Save state after setting time
                savePageState();
            } else {
                console.log('❌ Player not ready');
                showToast('Player not ready. Please wait for video to load.', 'warning');
            }
        }

        // Video Playback Control Functions
        function togglePlayPause() {
            if (!player || typeof player.getPlayerState !== 'function') {
                showToast('Player not ready', 'warning');
                return;
            }
            
            const playerState = player.getPlayerState();
            if (playerState === 1) { // Playing
                player.pauseVideo();
                if (toolbarPlayPause) {
                    toolbarPlayPause.innerHTML = '▶️ Play';
                    toolbarPlayPause.className = 'bg-green-500 hover:bg-green-600 text-white px-2 py-1 rounded text-xs transition';
                }
            } else { // Paused, ended, or buffering
                player.playVideo();
                if (toolbarPlayPause) {
                    toolbarPlayPause.innerHTML = '⏸️ Pause';
                    toolbarPlayPause.className = 'bg-yellow-500 hover:bg-yellow-600 text-white px-2 py-1 rounded text-xs transition';
                }
            }
        }
        
        function seekFrame(direction) {
            if (!player || typeof player.getCurrentTime !== 'function') {
                showToast('Player not ready', 'warning');
                return;
            }
            
            // Pause video first for precise frame navigation
            if (player.getPlayerState() === 1) { // If playing
                player.pauseVideo();
                // Update play/pause button state
                updatePlayPauseButton();
            }
            
            // YouTube videos are typically 30fps, so 1 frame = 1/30 second
            const frameTime = 1/30;
            const currentTime = player.getCurrentTime();
            const newTime = currentTime + (direction * frameTime);
            
            // Ensure we don't go below 0
            if (newTime < 0) {
                player.seekTo(0);
            } else {
                player.seekTo(newTime);
            }
            
            // Show feedback
            const frameText = direction > 0 ? '+1 frame' : '-1 frame';
            showToast(`Paused and seeked ${frameText}`, 'info');
        }
        
        // Set playback speed function
        function setPlaybackSpeed(speed) {
            if (!player || typeof player.setPlaybackRate !== 'function') {
                showToast('Player not ready', 'error');
                return;
            }
            
            try {
                player.setPlaybackRate(speed);
                
                // Update button states to show which speed is active
                if (toolbarSpeed50) {
                    if (speed === 0.5) {
                        toolbarSpeed50.className = 'bg-green-500 hover:bg-green-600 text-white px-2 py-1 rounded text-xs transition';
                    } else {
                        toolbarSpeed50.className = 'bg-purple-500 hover:bg-purple-600 text-white px-2 py-1 rounded text-xs transition';
                    }
                }
                
                if (toolbarSpeed150) {
                    if (speed === 1.5) {
                        toolbarSpeed150.className = 'bg-green-500 hover:bg-green-600 text-white px-2 py-1 rounded text-xs transition';
                    } else {
                        toolbarSpeed150.className = 'bg-purple-500 hover:bg-purple-600 text-white px-2 py-1 rounded text-xs transition';
                    }
                }
                
                // Show feedback
                const speedText = Math.round(speed * 100) + '%';
                showToast(`Playback speed set to ${speedText}`, 'info');
                
            } catch (error) {
                console.error('Error setting playback speed:', error);
                showToast('Failed to set playback speed', 'error');
            }
        }
        
        // Reset page to initial state
        function resetPageToInitialState() {
            console.log('🔄 Resetting page to initial state...');
            
            // Clear all video-related state
            currentVideoId = null;
            currentVideoTitle = null;
            tempStartTime = 0;
            tempEndTime = 0;
            
            // Clear all notes
            notes = [];
            allNotes = [];
            
            // Reset video player to initial state
            if (playerPlaceholder) {
                playerPlaceholder.style.display = 'block';
            }
            
            // Hide video controls toolbar
            if (videoControlsToolbar) {
                videoControlsToolbar.classList.add('hidden');
            }
            
            // Clear video URL input
            const urlInput = document.getElementById('url-input');
            if (urlInput) {
                urlInput.value = '';
            }
            
            // Clear note input fields
            if (noteText) {
                noteText.value = '';
            }
            if (toolbarStartTime) {
                toolbarStartTime.textContent = '00:00';
            }
            if (toolbarEndTime) {
                toolbarEndTime.textContent = '00:00';
            }
            
            // Hide any active loops
            if (stopLoopingBtn) {
                stopLoopingBtn.classList.add('hidden');
            }
            if (loopingStatus) {
                loopingStatus.textContent = '';
            }
            
            // Reset sidebar to collapsed state (default)
            if (mainContent) {
                mainContent.classList.add('sidebar-collapsed');
            }
            if (sidebar) {
                sidebar.classList.add('collapsed');
            }
            
            // Clear UI displays
            renderCurrentVideoNotes();
            renderAllNotesSidebar();
            updateUserProfile();
            
            console.log('✅ Page reset to initial state');
        }

        // State persistence functions
        function savePageState() {
            // SECURITY CHECK: Only save state if user is authenticated
            if (!currentUser) {
                console.log('🚨 Security: No authenticated user, cannot save state');
                return;
            }
            
            const state = {
                currentVideoId: currentVideoId,
                currentVideoTitle: currentVideoTitle,
                tempStartTime: tempStartTime,
                tempEndTime: tempEndTime,
                notes: notes,
                allNotes: allNotes,
                currentUser: currentUser,
                videoControlsVisible: videoControlsToolbar ? !videoControlsToolbar.classList.contains('hidden') : false,
                currentTheme: localStorage.getItem('selectedTheme') || 'light'
            };
            localStorage.setItem('youtubeNoteClipper_state', JSON.stringify(state));
        }
        
        function restorePageState() {
            try {
                const savedState = localStorage.getItem('youtubeNoteClipper_state');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    
                    // SECURITY CHECK: Only restore state if user is authenticated
                    if (!currentUser) {
                        console.log('🚨 Security: No authenticated user, clearing saved state');
                        localStorage.removeItem('youtubeNoteClipper_state');
                        return;
                    }
                    
                    // Restore basic state
                    currentVideoId = state.currentVideoId || '';
                    currentVideoTitle = state.currentVideoTitle || '';
                    tempStartTime = state.tempStartTime || 0;
                    tempEndTime = state.tempEndTime || 0;
                    notes = state.notes || [];
                    allNotes = state.allNotes || [];
                    
                    // Restore user if still valid
                    if (state.currentUser) {
                        if (USE_CLOUD) {
                            const cloudToken = localStorage.getItem('cloudToken');
                            if (cloudToken) {
                                currentUser = state.currentUser;
                            }
                        } else {
                            currentUser = state.currentUser;
                        }
                    }
                    
                    // Restore UI state
                    if (state.currentVideoId && state.currentVideoTitle) {
                        // Restore video player
                        if (typeof YT !== 'undefined' && YT.Player) {
                            player = new YT.Player('player', {
                                videoId: state.currentVideoId,
                                width: '100%',
                                height: '100%',
                                playerVars: { 
                                    'playsinline': 1, 
                                    'rel': 0,
                                    'modestbranding': 1,
                                    'showinfo': 0
                                },
                                events: { 'onPlayerReady': onPlayerReady }
                            });
                        }
                        
                        // Hide placeholder and show controls
                        if (playerPlaceholder) {
                            playerPlaceholder.style.display = 'none';
                        }
                        
                        // Show video controls toolbar
                        if (videoControlsToolbar) {
                            videoControlsToolbar.classList.remove('hidden');
                        }
                        
                        // Update time displays
                        if (toolbarStartTime) toolbarStartTime.textContent = formatTime(tempStartTime);
                        if (toolbarEndTime) toolbarEndTime.textContent = formatTime(tempEndTime);
                        
                        // Ensure notes are properly filtered for current video
                        if (state.currentVideoId && allNotes.length > 0) {
                            notes = allNotes.filter(note => note.videoId === state.currentVideoId);
                            console.log('✅ Restored notes filtered for video:', state.currentVideoId, 'Found:', notes.length, 'notes');
                        }
                        
                        // Render notes
                        renderCurrentVideoNotes();
                        renderAllNotesSidebar();
                        
                        showToast('Previous session restored!', 'success');
                    }
                    
                    // Restore theme if available
                    if (state.currentTheme) {
                        setTheme(state.currentTheme);
                    }
                }
            } catch (error) {
                console.error('Error restoring page state:', error);
            }
        }

        // Helper and UI Functions
        function resetNoteTaker() {
            noteText.value = '';
            tempStartTime = 0;
            tempEndTime = 0;

            if (toolbarStartTime) toolbarStartTime.textContent = '00:00';
            if (toolbarEndTime) toolbarEndTime.textContent = '00:00';
            
            // Hide stop looping button when resetting
            if (stopLoopingBtn) {
                stopLoopingBtn.classList.add('hidden');
            }
            
            // Clear looping status when resetting
            if (loopingStatus) {
                loopingStatus.textContent = '';
            }
            
            // Hide toolbar stop looping button when resetting
            if (toolbarStopLooping) {
                toolbarStopLooping.classList.add('hidden');
            }
            
            // Clear toolbar looping status when resetting
            if (toolbarLoopingStatus) {
                toolbarLoopingStatus.textContent = '';
            }
            
            // Hide header toolbar when resetting
            if (videoControlsToolbar) {
                videoControlsToolbar.classList.add('hidden');
            }
            
            // Reset speed buttons to default state
            if (toolbarSpeed50) {
                toolbarSpeed50.className = 'bg-purple-500 hover:bg-purple-600 text-white px-2 py-1 rounded text-xs transition';
            }
            if (toolbarSpeed150) {
                toolbarSpeed150.className = 'bg-purple-500 hover:bg-purple-600 text-white px-2 py-1 rounded text-xs transition';
            }
            
            // Reset playback speed to 100%
            if (player && typeof player.setPlaybackRate === 'function') {
                try {
                    player.setPlaybackRate(1.0);
                } catch (error) {
                    console.log('Could not reset playback speed');
                }
            }
        }

        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
            const seconds = (totalSeconds % 60).toString().padStart(2, '0');
            return `${minutes}:${seconds}`;
        }

        function showToast(message, type = 'info') {
            if (!toast) return;
            
            // Map type to colors and icons
            const toastConfig = {
                'success': { bg: 'bg-green-600', icon: '✅' },
                'error': { bg: 'bg-red-600', icon: '❌' },
                'warning': { bg: 'bg-yellow-600', icon: '⚠️' },
                'info': { bg: 'bg-blue-600', icon: 'ℹ️' }
            };
            
            const config = toastConfig[type] || toastConfig.info;
            
            toast.innerHTML = `${config.icon} ${message}`;
            toast.className = `fixed bottom-5 right-5 text-white py-2 px-4 rounded-lg shadow-lg transform transition-all duration-300 ${config.bg}`;
            toast.classList.remove('opacity-0', 'translate-y-2');
            toast.classList.add('opacity-100', 'translate-y-0');

            // Make error messages last longer
            const duration = type === 'error' ? 8000 : 3000;
            setTimeout(() => {
                toast.classList.remove('opacity-100', 'translate-y-0');
                toast.classList.add('opacity-0', 'translate-y-2');
            }, duration);
        }

        function escapeHTML(str) {
            const p = document.createElement('p');
            p.appendChild(document.createTextNode(str));
            return p.innerHTML;
        }

        // YouTube IFrame Player API Setup
        const tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        // YouTube API Ready
        function onYouTubeIframeAPIReady() {
            console.log('🎬 YouTube IFrame API Ready');
            
            // Set up periodic button state updates
            setInterval(() => {
                if (player && typeof player.getPlayerState === 'function') {
                    updatePlayPauseButton();
                }
            }, 1000); // Update every second
        }

        // Player ready event
        function onPlayerReady(event) {
            console.log('🎬 Player ready');
            // Note taker is now always visible, no need to show/hide
            console.log('✅ Note taking area is ready');
            
            // Set initial play/pause button state
            updatePlayPauseButton();
        }
        
        // Update play/pause button state based on player state
        function updatePlayPauseButton() {
            if (!toolbarPlayPause || !player || typeof player.getPlayerState !== 'function') return;
            
            const playerState = player.getPlayerState();
            if (playerState === 1) { // Playing
                toolbarPlayPause.innerHTML = '⏸️ Pause';
                toolbarPlayPause.className = 'bg-yellow-500 hover:bg-yellow-600 text-white px-2 py-1 rounded text-xs transition';
            } else { // Paused, ended, or buffering
                toolbarPlayPause.innerHTML = '▶️ Play';
                toolbarPlayPause.className = 'bg-green-500 hover:bg-green-600 text-white px-2 py-1 rounded text-xs transition';
            }
        }

        // Database health check and repair function
        window.checkDatabaseHealth = async function() {
            console.log('🏥 Checking database health...');
            
            if (!currentUser) {
                showToast('Please login first to check database health', 'error');
                return;
            }
            
            try {
                const token = localStorage.getItem('cloudToken');
                if (!token) {
                    showToast('No authentication token found', 'error');
                    return;
                }
                
                const response = await fetch(`${API_BASE}/health`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                if (response.ok) {
                    const healthData = await response.json();
                    console.log('🏥 Database health report:', healthData);
                    
                    // Show health summary
                    const { analysis } = healthData;
                    let message = `Database: ${healthData.status}\n`;
                    message += `Total notes: ${analysis.totalNotes}\n`;
                    message += `With ID: ${analysis.notesWithId}\n`;
                    message += `With database ID: ${analysis.notesWithMongoId}\n`;
                    message += `With both: ${analysis.notesWithBoth}\n`;
                    message += `With neither: ${analysis.notesWithNeither}`;
                    
                    if (analysis.notesWithNeither > 0) {
                        message += '\n⚠️ Some notes have corrupted IDs!';
                        showToast(message, 'warning');
                    } else if (analysis.notesWithBoth === analysis.totalNotes) {
                        message += '\n✅ All notes have consistent IDs!';
                        showToast(message, 'success');
                    } else {
                        message += '\n🔧 Some notes need ID repair';
                        showToast(message, 'info');
                    }
                    
                    // Auto-repair if needed
                    if (analysis.notesWithNeither > 0 || analysis.notesWithBoth < analysis.totalNotes) {
                        console.log('🔧 Auto-repairing database...');
                        await loadUserNotes(); // This will trigger the server-side repair
                        showToast('Database repair completed!', 'success');
                    }
                    
                } else {
                    const errorData = await response.json();
                    console.error('❌ Health check failed:', errorData);
                    showToast(`Health check failed: ${errorData.message}`, 'error');
                }
                
            } catch (error) {
                console.error('❌ Health check error:', error);
                showToast('Health check failed. Please try again.', 'error');
            }
        };

        // Debug function for edit issues
        window.debugEditIssue = function() {
            // SECURITY CHECK: Only allow debug for authenticated users
            if (!currentUser) {
                showToast('Please login first to use debug functions', 'error');
                return;
            }
            
            alert('Debug function called! Check console for details.');
            console.log('🐛 Debug Edit Issue');
            console.log('📊 Current state:', {
                currentVideoId,
                notes: notes,
                allNotes: allNotes,
                notesLength: notes.length,
                allNotesLength: allNotes.length
            });
            
            // Check DOM elements
            const noteElements = document.querySelectorAll('[data-note-id]');
            console.log('🔍 DOM elements with data-note-id:', Array.from(noteElements).map(el => ({
                tagName: el.tagName,
                className: el.className,
                dataNoteId: el.getAttribute('data-note-id')
            })));
            
            // Check specific note elements
            if (notes.length > 0) {
                const firstNote = notes[0];
                const noteId = firstNote._id || firstNote.id;
                console.log('🔍 First note ID:', noteId);
                
                const noteText = document.querySelector(`.note-text[data-note-id="${noteId}"]`);
                const noteEdit = document.querySelector(`.note-edit[data-note-id="${noteId}"]`);
                
                console.log('🔍 First note elements found:', {
                    noteText: !!noteText,
                    noteEdit: !!noteEdit
                });
            }
        };

        // View switching functions
        function switchToVideoNoteView() {
            document.getElementById('video-note-view').classList.remove('hidden');
            document.getElementById('note-preview-view').classList.add('hidden');
            document.getElementById('video-note-view-btn').classList.add('active-view');
            document.getElementById('video-note-view-btn').classList.remove('bg-gray-600');
            document.getElementById('video-note-view-btn').classList.add('bg-blue-600');
            document.getElementById('note-preview-view-btn').classList.remove('active-view');
            document.getElementById('note-preview-view-btn').classList.remove('bg-blue-600');
            document.getElementById('note-preview-view-btn').classList.add('bg-gray-600');
        }

        function switchToNotePreviewView() {
            document.getElementById('video-note-view').classList.add('hidden');
            document.getElementById('note-preview-view').classList.remove('hidden');
            document.getElementById('note-preview-view-btn').classList.add('active-view');
            document.getElementById('note-preview-view-btn').classList.remove('bg-gray-600');
            document.getElementById('note-preview-view-btn').classList.add('bg-blue-600');
            document.getElementById('video-note-view-btn').classList.remove('active-view');
            document.getElementById('video-note-view-btn').classList.remove('bg-blue-600');
            document.getElementById('video-note-view-btn').classList.add('bg-gray-600');
            renderNotePreview();
        }

        // Note preview rendering functions
        function renderNotePreview() {
            if (!currentUser || !allNotes || allNotes.length === 0) {
                document.getElementById('all-notes-preview').innerHTML = '<p class="text-gray-500 text-center py-8">No notes available</p>';
                return;
            }

            const container = document.getElementById('all-notes-preview');
            const sortValue = document.getElementById('sort-notes').value;
            
            // Sort notes based on selection
            let sortedNotes = [...allNotes];
            switch (sortValue) {
                case 'newest':
                    sortedNotes.sort((a, b) => new Date(b.createdAt || b.created_at) - new Date(a.createdAt || a.created_at));
                    break;
                case 'oldest':
                    sortedNotes.sort((a, b) => new Date(a.createdAt || a.created_at) - new Date(b.createdAt || b.created_at));
                    break;
                case 'alphabetical':
                    sortedNotes.sort((a, b) => a.text.localeCompare(b.text));
                    break;
                case 'video':
                    sortedNotes.sort((a, b) => a.videoTitle?.localeCompare(b.videoTitle) || a.videoId?.localeCompare(b.videoId));
                    break;
            }

            let notesHTML = '';
            sortedNotes.forEach((note, index) => {
                const noteId = note._id || note.id;
                notesHTML += `
                    <div class="bg-gray-50 border border-gray-200 rounded-lg p-4" data-note-id="${noteId}">
                        <div class="flex items-start justify-between mb-3">
                            <div class="flex-1">
                                <h4 class="font-semibold text-gray-800 mb-2">${escapeHTML(note.text.substring(0, 100))}${note.text.length > 100 ? '...' : ''}</h4>
                                <div class="text-sm text-gray-600 mb-2">
                                    <span class="font-mono">${formatTime(note.startTime)} → ${formatTime(note.endTime)}</span>
                                    <span class="mx-2">•</span>
                                    <span class="text-blue-600">${escapeHTML(note.videoTitle || note.videoId)}</span>
                                </div>
                                <div class="text-xs text-gray-500">
                                    Created: ${new Date(note.createdAt || note.created_at).toLocaleDateString()}
                                </div>
                            </div>
                                                            <div class="flex items-center space-x-2">
                                    <button onclick="toggleNoteExpansion('${noteId}')" class="text-blue-600 hover:text-blue-800 text-sm px-2 py-1 rounded border border-blue-200 hover:bg-blue-50">
                                        📖 Expand
                                    </button>
                                    <button onclick="editNotePreview('${noteId}')" class="text-green-600 hover:text-green-800 text-sm px-2 py-1 rounded border border-green-200 hover:bg-green-50">
                                        ✏️ Edit
                                    </button>
                                    <button onclick="deleteNotePreview('${noteId}')" class="text-red-600 hover:text-red-800 text-sm px-2 py-1 rounded border border-red-200 hover:bg-red-50">
                                        🗑️ Delete
                                    </button>
                                </div>
                        </div>
                        <div id="note-details-${noteId}" class="hidden mt-3 pt-3 border-t border-gray-200">
                            <div class="bg-white p-3 rounded border">
                                <div id="note-text-display-${noteId}">
                                    <p class="text-gray-700 text-sm">${escapeHTML(note.text)}</p>
                                </div>
                                <div id="note-edit-form-${noteId}" class="hidden">
                                    <div class="space-y-3">
                                        <div>
                                            <label class="block text-xs text-gray-600 mb-1">Start Time (seconds)</label>
                                            <input type="number" name="startTime" step="0.1" min="0" value="${note.startTime}" class="w-full p-2 border border-gray-300 rounded text-sm">
                                        </div>
                                        <div>
                                            <label class="block text-xs text-gray-600 mb-1">End Time (seconds)</label>
                                            <input type="number" name="endTime" step="0.1" min="0" value="${note.endTime}" class="w-full p-2 border border-gray-300 rounded text-sm">
                                        </div>
                                        <div>
                                            <label class="block text-xs text-gray-600 mb-1">Note Text</label>
                                            <textarea name="text" class="w-full p-2 border border-gray-300 rounded text-sm h-20">${escapeHTML(note.text)}</textarea>
                                        </div>
                                        <div class="flex space-x-2">
                                            <button onclick="saveNotePreviewEdit('${noteId}')" class="px-3 py-1 bg-green-500 text-white text-sm rounded hover:bg-green-600 transition">
                                                💾 Save
                                            </button>
                                            <button onclick="cancelNotePreviewEdit('${noteId}')" class="px-3 py-1 bg-gray-500 text-white text-sm rounded hover:bg-gray-600 transition">
                                                ❌ Cancel
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = notesHTML;
        }

        // Note expansion toggle
        function toggleNoteExpansion(noteId) {
            const detailsElement = document.getElementById(`note-details-${noteId}`);
            const button = event.target;
            
            if (detailsElement.classList.contains('hidden')) {
                detailsElement.classList.remove('hidden');
                button.textContent = '📕 Collapse';
                button.classList.remove('bg-blue-50', 'border-blue-200');
                button.classList.add('bg-yellow-50', 'border-yellow-200');
            } else {
                detailsElement.classList.add('hidden');
                button.textContent = '📖 Expand';
                button.classList.remove('bg-yellow-50', 'border-yellow-200');
                button.classList.add('bg-blue-50', 'border-blue-200');
            }
        }

        // Expand/Collapse all notes
        function expandAllNotes() {
            const noteElements = document.querySelectorAll('[id^="note-details-"]');
            const buttons = document.querySelectorAll('[onclick^="toggleNoteExpansion"]');
            
            noteElements.forEach(element => element.classList.remove('hidden'));
            buttons.forEach(button => {
                button.textContent = '📕 Collapse';
                button.classList.remove('bg-blue-50', 'border-blue-200');
                button.classList.add('bg-yellow-50', 'border-yellow-200');
            });
        }

        function collapseAllNotes() {
            const noteElements = document.querySelectorAll('[id^="note-details-"]');
            const buttons = document.querySelectorAll('[onclick^="toggleNoteExpansion"]');
            
            noteElements.forEach(element => element.classList.add('hidden'));
            buttons.forEach(button => {
                button.textContent = '📖 Expand';
                button.classList.remove('bg-yellow-50', 'border-yellow-200');
                button.classList.add('bg-blue-50', 'border-blue-200');
            });
        }

        // Note preview editing functions
        function editNotePreview(noteId) {
            const note = NoteIdManager.findNoteInArrays(noteId, allNotes);
            if (!note) {
                showToast('Note not found', 'error');
                return;
            }

            // Hide display, show edit form
            document.getElementById(`note-text-display-${noteId}`).classList.add('hidden');
            document.getElementById(`note-edit-form-${noteId}`).classList.remove('hidden');
            
            // Update button text
            const editButton = event.target;
            editButton.textContent = '✏️ Editing...';
            editButton.disabled = true;
            editButton.classList.add('opacity-50');
        }

        function saveNotePreviewEdit(noteId) {
            const note = NoteIdManager.findNoteInArrays(noteId, allNotes);
            if (!note) {
                showToast('Note not found', 'error');
                return;
            }

            const form = document.getElementById(`note-edit-form-${noteId}`);
            const startTimeInput = form.querySelector('input[name="startTime"]');
            const endTimeInput = form.querySelector('input[name="endTime"]');
            const textInput = form.querySelector('textarea[name="text"]');

            const startTime = parseFloat(startTimeInput.value);
            const endTime = parseFloat(endTimeInput.value);
            const text = textInput.value.trim();

            // Validation
            if (!text || text === '') {
                showToast('Note text is required', 'error');
                return;
            }

            if (isNaN(startTime) || isNaN(endTime)) {
                showToast('Start and end times must be valid numbers', 'error');
                return;
            }

            if (startTime >= endTime) {
                showToast('End time must be greater than start time', 'error');
                return;
            }

            // Update note data
            note.startTime = startTime;
            note.endTime = endTime;
            note.text = text;

            // Save to backend
            saveNotePreviewToBackend(noteId, startTime, endTime, text);
        }

        async function saveNotePreviewToBackend(noteId, startTime, endTime, text) {
            try {
                const token = localStorage.getItem('cloudToken');
                if (!token) {
                    showToast('No authentication token found', 'error');
                    return;
                }

                const response = await fetch(`${API_BASE}/notes/${noteId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        startTime,
                        endTime,
                        text
                    })
                });

                if (response.ok) {
                    showToast('Note updated successfully', 'success');
                    
                    // Update the note preview display
                    const note = NoteIdManager.findNoteInArrays(noteId, allNotes);
                    if (note) {
                        // Update the preview text
                        const previewText = document.querySelector(`[data-note-id="${noteId}"] h4`);
                        if (previewText) {
                            previewText.textContent = `${text.substring(0, 100)}${text.length > 100 ? '...' : ''}`;
                        }
                        
                        // Update the time display
                        const timeDisplay = document.querySelector(`[data-note-id="${noteId}"] .font-mono`);
                        if (timeDisplay) {
                            timeDisplay.textContent = `${formatTime(startTime)} → ${formatTime(endTime)}`;
                        }
                    }
                    
                    // Exit edit mode
                    exitNotePreviewEditMode(noteId);
                    
                    // Refresh the note preview
                    renderNotePreview();
                } else {
                    const errorData = await response.json();
                    showToast(`Failed to update note: ${errorData.message}`, 'error');
                }
            } catch (error) {
                console.error('Error updating note:', error);
                showToast('Failed to update note. Please try again.', 'error');
            }
        }

        function cancelNotePreviewEdit(noteId) {
            exitNotePreviewEditMode(noteId);
        }

        function exitNotePreviewEditMode(noteId) {
            // Hide edit form, show display
            document.getElementById(`note-text-display-${noteId}`).classList.remove('hidden');
            document.getElementById(`note-edit-form-${noteId}`).classList.add('hidden');
            
            // Reset button
            const editButton = document.querySelector(`[onclick="editNotePreview('${noteId}')"]`);
            if (editButton) {
                editButton.textContent = '✏️ Edit';
                editButton.disabled = false;
                editButton.classList.remove('opacity-50');
            }
        }

        function deleteNotePreview(noteId) {
            if (confirm('Are you sure you want to delete this note? This action cannot be undone.')) {
                deleteNote(noteId);
                // Refresh the note preview after deletion
                setTimeout(() => {
                    renderNotePreview();
                }, 500);
            }
        }

        console.log('✅ Cloud version JavaScript loaded successfully');
        console.log(`🌐 Using ${USE_CLOUD ? 'Cloud API' : 'localStorage'} for data storage`);
        
        // Test if debug function is available
        console.log('🔍 Debug function available:', typeof window.debugEditIssue);
        if (typeof window.debugEditIssue === 'function') {
            console.log('✅ Debug function is properly defined');
        } else {
            console.error('❌ Debug function is NOT defined');
        }
    </script>
</body>
</html>
